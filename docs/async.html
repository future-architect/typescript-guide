<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>非同期処理 &mdash; 仕事ですぐに使えるTypeScript  ドキュメント</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/translations.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="例外処理" href="exception.html" />
    <link rel="prev" title="クラス" href="class.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> 仕事ですぐに使えるTypeScript
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">TypeScriptの世界を知る</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preface.html">前書き</a></li>
<li class="toctree-l1"><a class="reference internal" href="ecosystem.html">Node.jsエコシステムを体験しよう</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TypeScriptの書き方</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="variable.html">変数</a></li>
<li class="toctree-l1"><a class="reference internal" href="primitive.html">プリミティブ型</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">複合型</a></li>
<li class="toctree-l1"><a class="reference internal" href="syntax.html">基本的な構文</a></li>
<li class="toctree-l1"><a class="reference internal" href="typing.html">基本的な型付け</a></li>
<li class="toctree-l1"><a class="reference internal" href="function.html">関数</a></li>
<li class="toctree-l1"><a class="reference internal" href="otherbuiltinobjects.html">その他の組み込み型・関数</a></li>
<li class="toctree-l1"><a class="reference internal" href="class.html">クラス</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">非同期処理</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">非同期とは何か</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">コールバックは使わない</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">非同期と制御構文</a></li>
<li class="toctree-l2"><a class="reference internal" href="#promise"><code class="docutils literal notranslate"><span class="pre">Promise</span></code> の分岐と待ち合わせの制御</a></li>
<li class="toctree-l2"><a class="reference internal" href="#await">ループの中の <code class="docutils literal notranslate"><span class="pre">await</span></code> に注意</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">非同期で繰り返し呼ばれる処理</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">まとめ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="exception.html">例外処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="module.html">モジュール</a></li>
<li class="toctree-l1"><a class="reference internal" href="console.html"><code class="docutils literal notranslate"><span class="pre">console.log</span></code>によるログ出力</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">中級のテクニック</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="generics.html">ジェネリクス</a></li>
<li class="toctree-l1"><a class="reference internal" href="functional.html">関数型指向のプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="class2.html">クラス上級編</a></li>
<li class="toctree-l1"><a class="reference internal" href="reactive.html">リアクティブ</a></li>
<li class="toctree-l1"><a class="reference internal" href="advance.html">高度なテクニック</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">環境ごとのTips（共通環境・ブラウザ以外）</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="prodenv.html">ソフトウェア開発の環境を考える</a></li>
<li class="toctree-l1"><a class="reference internal" href="baseenv.html">基本の環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="libenv.html">ライブラリ開発のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="clienv.html">CLIツール・ウェブサーバー作成のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">CI（継続的インテグレーション）環境の構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="deploy.html">成果物のデプロイ</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">使用ライブラリのバージョン管理</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">環境ごとのTips（ブラウザ環境）</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="browserenv.html">ブラウザ環境</a></li>
<li class="toctree-l1"><a class="reference internal" href="browserobjects.html">ブラウザ関連の組み込み型</a></li>
<li class="toctree-l1"><a class="reference internal" href="react.html">Reactの環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="vue.html">Vue.jsの環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="webparcel.html">Parcelを使ったウェブ開発</a></li>
<li class="toctree-l1"><a class="reference internal" href="electron.html">Electronアプリケーションの作成</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="recommended.html">おすすめのパッケージ・ツール</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html">貢献者</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">仕事ですぐに使えるTypeScript</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">非同期処理</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/async.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>非同期処理<a class="headerlink" href="#id1" title="この見出しへのパーマリンク"></a></h1>
<p>JavaScriptのエコシステムは伝統的にはスレッドを使わない計算モデルを使い、それの効率をあげる方向で進化してきました。
例えば、スリープのような、実行を行の途中で止めるような処理は基本的に持っていませんでした。
10秒間待つ、というタスクがあった場合には、10秒後に実行される関数を登録する、といった具合の処理が提供され、その場で「10秒止める」という処理を書く機能は提供されませんでした。</p>
<p>JavaScriptは伝統的に、ホストとなる環境（ブラウザ）の中で実行される、アプリケーション言語として使われることが多く、ホスト側のアプリケーションから見て、長時間ブロックされるなどの行儀の悪い動きをすることが忌避されてきたからではないかと思います。
そのせいかどうかわかりませんが、他の言語とは多少異なる進化を遂げてきました。</p>
<p>ブラウザでは、数々のHTML側のインタラクション、あるいはタイマーなどのイベントに対して、あらかじめ登録しておいたイベントハンドラの関数が呼ばれる、というモデルを採用しています。
JavaScriptがメインの処理系となるNode.jsでも、OSが行う、時間のかかる処理を受けるイベントループがあり、OS側の待ち処理に対してコールバック関数をあらかじめ登録しておきます。そして、結果の準備ができたら、それが呼ばれるというモデルです。</p>
<p>ES2015以降、このコーディングスタイルにも手が入り、土台の仕組みはコールバックではありますが、多数の非同期を効率よく扱う方法が整備されてきました。
現在、見かける非同期処理の書き方は大きく3種類あります。</p>
<ul class="simple">
<li><p>コールバック</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Promise</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">async</span></code> / <code class="docutils literal notranslate"><span class="pre">await</span></code></p></li>
</ul>
<p>本章ではそれらを紹介していきます。なお、非同期処理の例外処理については、例外処理の章で扱います。</p>
<section id="id2">
<h2>非同期とは何か<a class="headerlink" href="#id2" title="この見出しへのパーマリンク"></a></h2>
<p>JavaScriptの処理系には、現在のシステムのUIを担うレイヤーとしてかなりの開発資金が投入されてきました。
ブラウザ戦争と呼ばれる時期には、各ブラウザが競うようにJavaScriptやウェブブラウザの画面描画の速度向上を喧伝し、他社製のブラウザよりも優れていると比較のベンチマークを出していたりしました。
その結果としては、スクリプト言語としてはJavaScriptはトップクラスの速度になりました。Just In Timeコンパイラという実行時の最適化が効くと、コンパイル言語に匹敵する速度を出すことすらあります。</p>
<p>CPU速度が問題になることはあまりないとはいえ、コードで処理するタスクの中には長い時間の待ちを生じさせるものがいくつかあります。
例えば、タイマーなどもそうですし、外部のサーバーやデータベースへのネットワークアクセス、ローカルのファイルの読み書きなどは往復でミリ秒、場合によっては秒に近い遅延を生じさせます。
JavaScriptは、そのような時間のかかる処理は基本的に「非同期」という仕組みで処理を行います。
タイマー呼び出しをする次のコードを見てみます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;タイマー呼び出し前&quot;</span><span class="p">);</span><span class="w"></span>
<span class="nx">setTimeout</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;時間が来た&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">},</span><span class="w"> </span><span class="mf">1000</span><span class="p">);</span><span class="w"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;タイマー呼び出し後&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>このコードを実行すると次の順序でログが出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>タイマー呼び出し前
タイマー呼び出し後 // 上の行と同時に表示
時間が来た        // 1秒後に表示
</pre></div>
</div>
<p>JavaScriptでは時間のかかる処理を実行する場合、完了した後に呼び出す処理を処理系に渡すことはあっても、そこで処理を止めることはありません。
タイマーを設定する <code class="docutils literal notranslate"><span class="pre">setTimeout()</span></code> 関数の実行自体は即座に完了し、その次の行がすぐ呼ばれます。
そして時間のかかるタイマーの待ちが完了すると、渡してあった関数が実行されます。
処理が終わるのをじっくり待つ（同期）のではなく、完了したら後から連絡してもらう（非同期）のがJavaScriptのスタイルです。</p>
<p>昔のJavaScriptのコードでは、時間のかかる処理を行う関数は、かならず引数の最後がコールバック関数でした。
このコールバック関数の中にコードを書くことで、時間のかかる処理が終わったあとに実行する、というのが表現できました。</p>
</section>
<section id="id3">
<h2>コールバックは使わない<a class="headerlink" href="#id3" title="この見出しへのパーマリンク"></a></h2>
<p>以前はJavaScriptで数多くの非同期処理を実装しようとすると、多数のコールバック関数を扱う必要があり、以前はコールバック地獄と揶揄されていました。</p>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text">非同期の書き方</span><a class="headerlink" href="#id11" title="このコードへのパーマリンク"></a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="c1">// 旧: Promise以前</span><span class="w"></span>
<span class="nx">func1</span><span class="p">(</span><span class="nx">引数</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">err</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="nx">func2</span><span class="p">(</span><span class="nx">引数</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">err</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nx">func3</span><span class="p">(</span><span class="nx">引数</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 最後に実行されるコードブロック</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>その後、<code class="docutils literal notranslate"><span class="pre">Promise</span></code>が登場し、ネストが1段になり、書きやすく、読みやすくなりました。
<code class="docutils literal notranslate"><span class="pre">Promise</span></code>はその名の通り「重たい仕事が終わったら、あとで呼びに来るからね」という約束です。
これにより、上記のような、深いネストがされたコードを触れる必要が減ってきました。
何階層もの待ちが発生しても、1段階のネストで済むようになりました。</p>
<p>この <code class="docutils literal notranslate"><span class="pre">Promise</span></code> の実装は、文法の進化に頼ることなく、既存のJavaScriptの文法の上で実装されたトリックで実現できました。
コミュニティベースで実現されたソリューションです。
この <code class="docutils literal notranslate"><span class="pre">Promise</span></code> は現在も生き続けている方法です。直接書く機会は減ると思いますが、 <code class="docutils literal notranslate"><span class="pre">Promise</span></code> について学んだことは無駄にはなりません。</p>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-text">非同期の書き方</span><a class="headerlink" href="#id12" title="このコードへのパーマリンク"></a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="c1">// 中: Promise以後</span><span class="w"></span>
<span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">resp</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">resp</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span><span class="w"></span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">json</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span><span class="w"></span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// エラー発生時にここを通過する</span><span class="w"></span>
<span class="p">}).</span><span class="k">finally</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// エラーが発生しても、正常終了時もここを通過する</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> の <code class="docutils literal notranslate"><span class="pre">then()</span></code> 節の中に、前の処理が終わった時に呼び出して欲しいコードを書きます。
また、その <code class="docutils literal notranslate"><span class="pre">then()</span></code> のレスポンスもまた <code class="docutils literal notranslate"><span class="pre">Promise</span></code> なので、連続して書けるというわけです。
また、この <code class="docutils literal notranslate"><span class="pre">then()</span></code> の中で <code class="docutils literal notranslate"><span class="pre">return</span></code> で返されたものが次の <code class="docutils literal notranslate"><span class="pre">then()</span></code> の入力になります。
<code class="docutils literal notranslate"><span class="pre">then()</span></code> の中で <code class="docutils literal notranslate"><span class="pre">Promise</span></code> を返すと、その返された <code class="docutils literal notranslate"><span class="pre">Promise</span></code> が解決すると、その結果が次の <code class="docutils literal notranslate"><span class="pre">then()</span></code> の入力になります。遅い処理を割り込ませるイメージです。
<code class="docutils literal notranslate"><span class="pre">catch()</span></code> と <code class="docutils literal notranslate"><span class="pre">finally()</span></code> は通常の例外処理と同じです。 <code class="docutils literal notranslate"><span class="pre">finally()</span></code> はES2018で取り込まれた機能です。</p>
<p>コールバック地獄では、コードの呼び出し順が上から下ではなく上→下→中と分断されてしまいますが、 <code class="docutils literal notranslate"><span class="pre">Promise</span></code> の <code class="docutils literal notranslate"><span class="pre">then()</span></code> 節だけをみれば、上から下に順序良く流れているように見えます。
初めて見ると面食らうかもしれませんが、慣れてくるとコールバックよりも流れは追いやすいでしょう。</p>
<p>この <code class="docutils literal notranslate"><span class="pre">Promise</span></code> がJavaScript標準の方法として決定されると、さらなる改善のために<code class="docutils literal notranslate"><span class="pre">await</span></code>という新しいキーワードが導入されました。
これは <code class="docutils literal notranslate"><span class="pre">Promise</span></code> を使ったコードの、 <code class="docutils literal notranslate"><span class="pre">then()</span></code> 節の中だけを並べたのとほぼ等価になります。
それにより、さらにフラットに書けるようになりましたし、行数も半分になります。
内部的には、<code class="docutils literal notranslate"><span class="pre">await</span></code>はまったく新しい機構というわけではなく、<code class="docutils literal notranslate"><span class="pre">Promise</span></code>を扱いやすくする糖衣構文で、<code class="docutils literal notranslate"><span class="pre">then()</span></code>を呼び出し、その引数で渡される値が関数の返り値となるように動作します。
<code class="docutils literal notranslate"><span class="pre">Promise</span></code> 対応のコードを書くのと、 <code class="docutils literal notranslate"><span class="pre">await</span></code> 対応のコードを書くのは差がありません。
<code class="docutils literal notranslate"><span class="pre">Promise</span></code> でない返り値の関数の前に <code class="docutils literal notranslate"><span class="pre">await</span></code> を書いても処理が止まることはありません（エラーになることはありません）。</p>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-text">非同期の書き方</span><a class="headerlink" href="#id13" title="このコードへのパーマリンク"></a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="c1">// 新: 非同期処理をawaitで待つ（ただし、awaitはasync関数の中でのみ有効）</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">resp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">resp</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span><span class="w"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">await</span></code> を扱うには、 <code class="docutils literal notranslate"><span class="pre">async</span></code> をつけて定義された関数でなければなりません。
TypeScriptでは、 <code class="docutils literal notranslate"><span class="pre">async</span></code> を返す関数の返り値は必ず <code class="docutils literal notranslate"><span class="pre">Promise</span></code> になります。
ジェネリクスのパラメータとして、返り値の型を設定します。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="nb">Promise</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">await</span><span class="w"> </span><span class="nx">時間のかかる処理</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mf">10</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>なお、 <code class="docutils literal notranslate"><span class="pre">Promise</span></code> を返す関数は、関数の宣言文を見たときに動作が理解しやすくなるので <code class="docutils literal notranslate"><span class="pre">async</span></code> をつけておく方が良いでしょう。ESLintのTypeScriptプラグインでも、推奨設定でこのように書くことを推奨しています<a class="footnote-reference brackets" href="#id5" id="id4">1</a> 。</p>
<p>TypeScriptの処理系は、この <code class="docutils literal notranslate"><span class="pre">Promise</span></code> の種類と、関数の返り値の型が同一かどうかを判断し、マッチしなければエラーを出してくれます。
非同期処理の場合、実際に動かしてデバッグしようにも、送る側の値と、受ける側に渡ってくる値が期待通りかどうかを確認するのが簡単ではありません。
ログを出してみても、実際に実行されるタイミングがかなりずれていることがありえます。
TypeScriptを使うメリットには、このように実際に動かすデバッグが難しいケースでも、型情報を使って「失敗するとわかっている実装」を見つけてくれる点にあります。</p>
<p>比較的新しく作られたライブラリなどは最初から<code class="docutils literal notranslate"><span class="pre">Promise</span></code>を返す実装になっていると思いますが、そうでないコールバック関数方式のコードを扱う時は <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Promise</span></code>を使って<code class="docutils literal notranslate"><span class="pre">Promise</span></code>化します。</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="c1">// setTimeoutは最初がコールバックという変態仕様なので仕方なくnew Promise</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">sleep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">time</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">resolve</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">setTimeout</span><span class="p">(()=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">resolve</span><span class="p">(</span><span class="nx">time</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="nx">time</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">await</span><span class="w"> </span><span class="nx">sleep</span><span class="p">(</span><span class="mf">100</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>末尾がコールバック、コールバックの先頭の引数はErrorという、2010年代の行儀の良いAPIであれば、<code class="docutils literal notranslate"><span class="pre">Promise</span></code>化してくれるライブラリがあります。
Node.js標準にもありますし、npmで調べてもたくさんあります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// Node.js標準ライブラリのpromisifyを使う</span><span class="w"></span>

<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">promisify</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;util&quot;</span><span class="p">;</span><span class="w"></span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">readFile</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;fs&quot;</span><span class="p">;</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">readFileAsync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">promisify</span><span class="p">(</span><span class="nx">readFile</span><span class="p">);</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">readFileAsync</span><span class="p">(</span><span class="s2">&quot;package.json&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;utf8&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id4">1</a></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">&#64;typescript-eslint/promise-function-async</span></code> という設定が該当します。</p>
</dd>
</dl>
</section>
<section id="id6">
<h2>非同期と制御構文<a class="headerlink" href="#id6" title="この見出しへのパーマリンク"></a></h2>
<p>TypeScriptで提供されている <code class="docutils literal notranslate"><span class="pre">if</span></code> や <code class="docutils literal notranslate"><span class="pre">for</span></code> 、 <code class="docutils literal notranslate"><span class="pre">while</span></code> などは関数呼び出しを伴わないフラットなコードなので<code class="docutils literal notranslate"><span class="pre">await</span></code>とも一緒に使えます。
<code class="docutils literal notranslate"><span class="pre">Promise</span></code> やコールバックを使ったコードで、条件によって非同期処理を1つ追加する、というコードを書くのは大変です。
試しに、TypeScriptのPlayGroundで下記のコードを変換してみるとどうなるか見てみると複雑さにひっくり返るでしょう。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// たまに実行される</span><span class="w"></span>
<span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">randomRun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 必ず実行される</span><span class="w"></span>
<span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">finallyFunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mf">2</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">randomRun</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">await</span><span class="w"> </span><span class="nx">finallyFunc</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="nx">main</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>これを見ると、 <code class="docutils literal notranslate"><span class="pre">await</span></code> は条件が複雑なケースでも簡単に非同期を含むコードを扱えるのがメリットであることが理解できるでしょう。</p>
<p><code class="docutils literal notranslate"><span class="pre">await</span></code> を使うと、ループを一回回るたびに重い処理が完了するのを待つことができます。
同じループでも、配列の <code class="docutils literal notranslate"><span class="pre">forEach()</span></code> を使うと、1要素ごとに <code class="docutils literal notranslate"><span class="pre">await</span></code> で待つことはできませんし、すべてのループの処理が終わったあとに、何かを行わせることもできません。</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="c1">// for of, if, while, switchはawaitとの相性も良い</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">iterable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">await</span><span class="w"> </span><span class="nx">doSomething</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;この行は全部のループが終わったら実行される&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="c1">// このawaitでは待たずにループが終わってしまう</span><span class="w"></span>
<span class="nx">iterable</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="k">async</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">await</span><span class="w"> </span><span class="nx">doSomething</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;この行はループ内の各処理が回る前に即座に実行される&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="promise">
<h2><code class="docutils literal notranslate"><span class="pre">Promise</span></code> の分岐と待ち合わせの制御<a class="headerlink" href="#promise" title="この見出しへのパーマリンク"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> は「時間がかかる仕事が終わった時に通知するという約束」という説明をしました。
みなさんは普段の生活で、時間がかかるタスクというのを行ったことがありますよね？
味噌汁をガスレンジで温めつつ、ご飯を電子レンジで温め、両方終わったらいただきます、という具合です。
<code class="docutils literal notranslate"><span class="pre">Promise</span></code> および、その完了を待つ <code class="docutils literal notranslate"><span class="pre">await</span></code> を使えば、そのようなタスクも簡単に実装できます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">味噌汁温め</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">味噌汁</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">await</span><span class="w"> </span><span class="nx">ガスレンジ</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">味噌汁</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">ご飯温め</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">ご飯</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">await</span><span class="w"> </span><span class="nx">電子レンジ</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">ご飯</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">a味噌汁</span><span class="p">,</span><span class="w"> </span><span class="nx">aご飯</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">味噌汁温め</span><span class="p">(),</span><span class="w"> </span><span class="nx">ご飯温め</span><span class="p">()]);</span><span class="w"></span>
<span class="nx">いただきます</span><span class="p">(</span><span class="nx">a味噌汁</span><span class="p">,</span><span class="w"> </span><span class="nx">aご飯</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">味噌汁温め()</span></code> と <code class="docutils literal notranslate"><span class="pre">ご飯温め()</span></code> は <code class="docutils literal notranslate"><span class="pre">async</span></code> がついた関数です。
省略可能ですがあえて返り値に <code class="docutils literal notranslate"><span class="pre">Promise</span></code> をつけています。
これまでの例では、 <code class="docutils literal notranslate"><span class="pre">async</span></code> 関数を呼ぶ時には <code class="docutils literal notranslate"><span class="pre">await</span></code> をつけていました。
<code class="docutils literal notranslate"><span class="pre">await</span></code> をつけると、待った後の結果（ここでは味噌汁とご飯のインスタンス）が返ってきます。
<code class="docutils literal notranslate"><span class="pre">await</span></code> をつけないと、 <code class="docutils literal notranslate"><span class="pre">Promise</span></code> そのものが返ってきます。</p>
<p>この <code class="docutils literal notranslate"><span class="pre">Promise</span></code> の配列を受け取り、全部の <code class="docutils literal notranslate"><span class="pre">Promise</span></code> が完了するのを待つのが <code class="docutils literal notranslate"><span class="pre">Promise.all()</span></code> です。
<code class="docutils literal notranslate"><span class="pre">Promise.all()</span></code> は、引数のすべての結果が得られると、解決して結果をリストで返す <code class="docutils literal notranslate"><span class="pre">Promise</span></code> を返します。
<code class="docutils literal notranslate"><span class="pre">Promise.all()</span></code> の結果を <code class="docutils literal notranslate"><span class="pre">await</span></code> すると、すべての結果がまとめて得られます。</p>
<p>この <code class="docutils literal notranslate"><span class="pre">Promise.all()</span></code> は、複数のウェブリクエストを同時に並行で行い、全てが出揃ったら画面を描画する、など多くの場面で使えます。
ループで複数の要素を扱う場合も使えます。</p>
<p>なお、 <code class="docutils literal notranslate"><span class="pre">Promise.all()</span></code> の引数の配列に、 <code class="docutils literal notranslate"><span class="pre">Promise</span></code> 以外の要素があると、即座に完了する <code class="docutils literal notranslate"><span class="pre">Promise</span></code> として扱われます。</p>
<p>類似の関数で <code class="docutils literal notranslate"><span class="pre">Promise.race()</span></code> というものがあります。
これは <code class="docutils literal notranslate"><span class="pre">all()</span></code> と似ていますが、全部が揃うと実行されるわけではなく、どれか一つでも完了すると呼ばれます。
レスポンスの値は、引数のうちのどれか、ということで、結果を受け取る場合は処理が少し複雑になります。
結果を扱わずに、5秒のアニメーションが完了するか、途中でクリックした場合には画面を更新する、みたいな処理には適しているかもしれません。</p>
</section>
<section id="await">
<h2>ループの中の <code class="docutils literal notranslate"><span class="pre">await</span></code> に注意<a class="headerlink" href="#await" title="この見出しへのパーマリンク"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">for</span></code> ループと <code class="docutils literal notranslate"><span class="pre">await</span></code> が併用できることはすでに紹介しました。
しかし、このコード自体は問題があります。</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">iterable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">await</span><span class="w"> </span><span class="nx">doSomething</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>この <code class="docutils literal notranslate"><span class="pre">doSomething()</span></code> の中で外部APIを呼び出しているとすると、要素数×アクセスにかかる時間だけ、処理時間がかかります。
要素数が多い場合、要素数に比例して処理時間が伸びます。
この <code class="docutils literal notranslate"><span class="pre">await</span></code> を内部にもつループがボトルネックとなり、ユーザーレスポンスが遅れることもありえるかもしれません。
上記のような例を紹介はしましたが、基本的にループ内の <code class="docutils literal notranslate"><span class="pre">await</span></code> は警戒すべきコードです。</p>
<p>この場合、 <code class="docutils literal notranslate"><span class="pre">Promise.all()</span></code> を使うと、全部の重い処理を同時に投げ、一番遅い最後の処理が終わるまで待つことができます。
配列の <code class="docutils literal notranslate"><span class="pre">map()</span></code> は、配列の中のすべての要素を、指定の関数に通し、その結果を格納する新しい配列（元の配列と同じ長さ）を作り出して返します。
詳しくは関数型スタイルのコーディングの紹介で触れますが、このメソッドを使うと、上記の例のような、 <code class="docutils literal notranslate"><span class="pre">Promise</span></code> の配列を作ることができます。
<code class="docutils literal notranslate"><span class="pre">Promise.all()</span></code> の引数は、 <code class="docutils literal notranslate"><span class="pre">Promise</span></code> の配列ですので、これをそのまま渡すと、全部の処理が終わるのを待つ、という処理が完成します。</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="k">await</span><span class="w"> </span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="nx">iterable</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">doSomething</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>図で見てみると、この違いは一目瞭然でしょう。</p>
<figure class="align-default">
<img alt="_images/loop.png" src="_images/loop.png" />
</figure>
<p><code class="docutils literal notranslate"><span class="pre">Promise.all()</span></code> が適切ではない場面もいくつかあります。</p>
<p>例えば、外部のAPI呼び出しをする場合、たいてい、秒間あたりのアクセス数が制限されています。
配列に100個の要素があるからといって100並列でリクエストを投げるとエラーが返ってきて正常に処理が終了しないこともありえます。
その場合は、並列数を制御しつつ <code class="docutils literal notranslate"><span class="pre">map()</span></code> と同等のことを実現してくれる <code class="docutils literal notranslate"><span class="pre">p-map</span></code> <a class="footnote-reference brackets" href="#id8" id="id7">2</a> といったライブラリを活用すると良いでしょう。</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id7">2</a></span></dt>
<dd><p><a class="reference external" href="https://www.npmjs.com/package/p-map">https://www.npmjs.com/package/p-map</a></p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">for</span></code> ループ内部の <code class="docutils literal notranslate"><span class="pre">await</span></code> のように、順番に処理をするための専用構文もあります。
<code class="docutils literal notranslate"><span class="pre">asyncIterator</span></code> というプロトコルを実装したオブジェクトでは、<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">await</span> <span class="pre">(const</span> <span class="pre">element</span> <span class="pre">of</span> <span class="pre">obj)</span></code>というES2018で導入された構文も使えるようになります。<code class="docutils literal notranslate"><span class="pre">fetch</span></code> のレスポンスのボディがそれにあたります。
普段は <code class="docutils literal notranslate"><span class="pre">json()</span></code> メソッドなどで一括で変換結果を受け取ると思いますが、細切れのブロック単位で受信することもできます。
この構文を使うと、それぞれのブロックごとにループを回す、という処理が行えます。
ただし、それ以外の用途は今のところ見かけませんし、この用途で使うところも見たことがありませんので、基本的にはループの中の <code class="docutils literal notranslate"><span class="pre">await</span></code> は要注意であることは変わりありません。</p>
</section>
<section id="id9">
<h2>非同期で繰り返し呼ばれる処理<a class="headerlink" href="#id9" title="この見出しへのパーマリンク"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">async</span></code>/<code class="docutils literal notranslate"><span class="pre">await</span></code>は便利なものですが、ワンショットで終わるイベント向けです。繰り返し行われるイベント（<code class="docutils literal notranslate"><span class="pre">addEventListener()</span></code>を使うようなスクロールイベントとか、画面のリサイズ、<code class="docutils literal notranslate"><span class="pre">setInterval()</span></code>の繰り返しタイマー）に対しては引き続きコールバック関数を登録して使います。</p>
<p>そこをモダンにしようという動きには<a class="reference external" href="https://rxjs-dev.firebaseapp.com/guide/overview">RxJS</a>があります。</p>
</section>
<section id="id10">
<h2>まとめ<a class="headerlink" href="#id10" title="この見出しへのパーマリンク"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> と <code class="docutils literal notranslate"><span class="pre">await</span></code> について紹介しました。
非同期は本質的に、難しい処理です。
その難しい処理をなるべく簡単に表現しよう、という試みがむかしから試行錯誤されてきました。
その1つの成果がこのTypeScriptで扱えるこの2つの要素です。</p>
<p>上から順番に実行されるわけではありませんし、なかなかイメージが掴みにくいかもしれません。
最終的には、頭の中で、どの部分が並行で実行されて、どこで待ち合わせをするか、それがイメージができれば、
非同期処理の記述に強いTypeScriptのパフォーマンスを引き出せるでしょう。</p>
<p>非同期処理を扱うライブラリとして、より高度な処理を実現するためのrxJSというものがあります。これはリアクティブの章で紹介します。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="class.html" class="btn btn-neutral float-left" title="クラス" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="exception.html" class="btn btn-neutral float-right" title="例外処理" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020, Future Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>