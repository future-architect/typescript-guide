<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>複合型 &mdash; 仕事ですぐに使えるTypeScript  ドキュメント</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/translations.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="基本的な構文" href="syntax.html" />
    <link rel="prev" title="プリミティブ型" href="primitive.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> 仕事ですぐに使えるTypeScript
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">TypeScriptの世界を知る</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preface.html">前書き</a></li>
<li class="toctree-l1"><a class="reference internal" href="ecosystem.html">Node.jsエコシステムを体験しよう</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TypeScriptの書き方</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="variable.html">変数</a></li>
<li class="toctree-l1"><a class="reference internal" href="primitive.html">プリミティブ型</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">複合型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">配列</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">タプル</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">配列からのデータの取り出し</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">配列の要素の存在チェック</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">配列の加工</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">配列のソート</a></li>
<li class="toctree-l3"><a class="reference internal" href="#for-of">ループは<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">of</span></code>を使う</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iterable">iterableとイテレータ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">読み込み専用の配列</a></li>
<li class="toctree-l3"><a class="reference internal" href="#typescript">TypeScriptと配列</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">配列のようで配列でない、ちょっと配列なオブジェクト</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id10">オブジェクト</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#json-javascript-object-notation">JSON（JavaScript Object Notation）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">オブジェクトからのデータの取り出し</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">オブジェクトの要素の加工</a></li>
<li class="toctree-l3"><a class="reference internal" href="#map">辞書用途はオブジェクトではなくて<code class="docutils literal notranslate"><span class="pre">Map</span></code>を使う</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">TypeScriptとオブジェクト</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">読み込み専用のオブジェクト</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id15">まとめ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="syntax.html">基本的な構文</a></li>
<li class="toctree-l1"><a class="reference internal" href="typing.html">基本的な型付け</a></li>
<li class="toctree-l1"><a class="reference internal" href="function.html">関数</a></li>
<li class="toctree-l1"><a class="reference internal" href="otherbuiltinobjects.html">その他の組み込み型・関数</a></li>
<li class="toctree-l1"><a class="reference internal" href="class.html">クラス</a></li>
<li class="toctree-l1"><a class="reference internal" href="async.html">非同期処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="exception.html">例外処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="module.html">モジュール</a></li>
<li class="toctree-l1"><a class="reference internal" href="console.html"><code class="docutils literal notranslate"><span class="pre">console.log</span></code>によるログ出力</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">中級のテクニック</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="generics.html">ジェネリクス</a></li>
<li class="toctree-l1"><a class="reference internal" href="functional.html">関数型指向のプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="class2.html">クラス上級編</a></li>
<li class="toctree-l1"><a class="reference internal" href="reactive.html">リアクティブ</a></li>
<li class="toctree-l1"><a class="reference internal" href="advance.html">高度なテクニック</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">環境ごとのTips（共通環境・ブラウザ以外）</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="prodenv.html">ソフトウェア開発の環境を考える</a></li>
<li class="toctree-l1"><a class="reference internal" href="baseenv.html">基本の環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="libenv.html">ライブラリ開発のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="clienv.html">CLIツール・ウェブサーバー作成のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">CI（継続的インテグレーション）環境の構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="deploy.html">成果物のデプロイ</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">使用ライブラリのバージョン管理</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">環境ごとのTips（ブラウザ環境）</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="browserenv.html">ブラウザ環境</a></li>
<li class="toctree-l1"><a class="reference internal" href="browserobjects.html">ブラウザ関連の組み込み型</a></li>
<li class="toctree-l1"><a class="reference internal" href="react.html">Reactの環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="vue.html">Vue.jsの環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="webparcel.html">Parcelを使ったウェブ開発</a></li>
<li class="toctree-l1"><a class="reference internal" href="electron.html">Electronアプリケーションの作成</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="recommended.html">おすすめのパッケージ・ツール</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html">貢献者</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">仕事ですぐに使えるTypeScript</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">複合型</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/complex.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>複合型<a class="headerlink" href="#id1" title="この見出しへのパーマリンク"></a></h1>
<p>他のプリミティブ型、もしくは複合型自身を内部に含み、大きなデータを定義できるデータ型を「複合型」と呼びます。
配列、オブジェクトなどがこれにあたります。クラスを定義して作るインスタンスも複合型ですが、リテラルで定義できる配列、およびオブジェクトをここでは取り上げます。</p>
<section id="id2">
<h2>配列<a class="headerlink" href="#id2" title="この見出しへのパーマリンク"></a></h2>
<p>配列はTypeScriptの中でかなり多用されるリテラルですが、スプレッド構文、分割代入などが加わり、また、数々のメソッドを駆使することで、関数型言語のような書き方もできます。
配列は、次に紹介するオブジェクトと同様、リテラルで定義できる複合型の1つです。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 変数に代入。型名を付けるときは配列に入れる要素の型名の後ろに[]を付与する</span><span class="w"></span>
<span class="c1">// 後ろの型が明確であれば型名は省略可能</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">years</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">2019</span><span class="p">,</span><span class="w"> </span><span class="mf">2020</span><span class="p">,</span><span class="w"> </span><span class="mf">2021</span><span class="p">];</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">divs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s1">&#39;tig&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;sig&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;saig&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;scig&#39;</span><span class="p">];</span><span class="w"></span>

<span class="c1">// 配列に要素を追加。複数個も追加可能</span><span class="w"></span>
<span class="nx">years</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mf">2022</span><span class="p">);</span><span class="w"></span>
<span class="nx">years</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mf">2023</span><span class="p">,</span><span class="w"> </span><span class="mf">2024</span><span class="p">);</span><span class="w"></span>

<span class="c1">// 要素から取り出し</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">years</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<section id="id3">
<h3>タプル<a class="headerlink" href="#id3" title="この見出しへのパーマリンク"></a></h3>
<p>Javaなどの配列は要素のすべての型は同じです。TypeScriptでは、配列の要素ごとに型が違う「タプル」というデータ型も定義できます。
裏のデータ型は配列ですが、コンパイラが特殊なモードの配列として扱います。
この場合違う型を入れようとするとエラーになります。
後述の<code class="docutils literal notranslate"><span class="pre">readonly</span></code>を使うことで読み込み専用のタプルを作ることもできますが、デフォルトは変更可能です。</p>
<p>配列のインデックスごとに何を入れるか、名前をつけることはできないため、積極的に使うことはないでしょう。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">movie</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">number</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s1">&#39;Gozilla&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">1954</span><span class="p">];</span><span class="w"></span>
<span class="nx">movie</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2019</span><span class="p">;</span><span class="w"></span>
<span class="c1">// error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</span><span class="w"></span>
</pre></div>
</div>
<p>固定長の配列を表現する手段としても利用できます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10</span><span class="p">;</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">pos</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="kt">number</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">r</span><span class="p">),</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">r</span><span class="p">)];</span><span class="w"></span>
<span class="c1">// Tuple type &#39;[number, number]&#39; of length &#39;2&#39; has no element at index &#39;2&#39;.</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">[string,</span> <span class="pre">...string[]]</span></code>と書けば、1つは必ず要素があり、2つ以上の要素が格納できるタプル、というのも表現できますが、「これよりも少ない」は表現できません。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>Pythonにもタプルはあります。これは要素の変更が不可能で、辞書のキーに使えたりするということで、配列とはかなり性質が異なっていて、言語にとっては重要な要素となっています。</p>
<p>一方、通常のデータ型として使うにはやはりインデックスアクセスしかできないため、可読性が劣り、インデックスとデータの種類の対応付けを人間が覚えるのはストレスがあるため、かなり初期から<code class="docutils literal notranslate"><span class="pre">namedtuple</span></code>（名前付きタプル）と呼ばれるクラスが提供されています。これは名前で要素アクセスができる、タプルと可換なデータ構造です。</p>
<p>TypeScriptの場合はリテラルで簡単にオブジェクトが作れますし、多くのタプルはオブジェクトで代替可能でしょう。</p>
</div>
</section>
<section id="id4">
<h3>配列からのデータの取り出し<a class="headerlink" href="#id4" title="この見出しへのパーマリンク"></a></h3>
<p>以前のJavaScriptは、配列やオブジェクトの中身を変数に取り出すには一つずつ取り出すしかありませんでした。
現在のJavaScriptとTypeScriptは、分割代入（<code class="docutils literal notranslate"><span class="pre">=</span></code>の左に配列を書く記法）を使って複数の要素をまとめて取り出すことができます。
<code class="docutils literal notranslate"><span class="pre">slice()</span></code>を使わずに、新しい残余（Rest）構文（<code class="docutils literal notranslate"><span class="pre">...</span></code>）を使って、複数の要素をまとめて取り出すことができます。</p>
<p>残余構文は省略記号のようにピリオドを3つ書く構文で、あたかも複数の要素がそこにあるかのように振る舞います。
残余構文は取り出し以外にも、配列やオブジェクトの加工、関数呼び出しの引数リストに対しても使える強力な構文です。
ここでは、2つめ以降のすべての要素を<code class="docutils literal notranslate"><span class="pre">other</span></code>に格納しています。</p>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-text">配列の要素の取り出し</span><a class="headerlink" href="#id16" title="このコードへのパーマリンク"></a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">smalls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">  </span><span class="s2">&quot;小動物&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s2">&quot;小型車&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s2">&quot;小論文&quot;</span><span class="w"></span>
<span class="p">];</span><span class="w"></span>
<span class="c1">// 旧: 一個ずつ取り出す</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">smallCar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smalls</span><span class="p">[</span><span class="mf">1</span><span class="p">];</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smalls</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span><span class="w"></span>
<span class="c1">// 旧: 2番目以降の要素の取り出し</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">other</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smalls</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">1</span><span class="p">);</span><span class="w"></span>

<span class="c1">// 新: まとめて取り出し</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">smallAnimal</span><span class="p">,</span><span class="w"> </span><span class="nx">smallCar</span><span class="p">,</span><span class="w"> </span><span class="nx">essay</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smalls</span><span class="p">;</span><span class="w"></span>
<span class="c1">// 新: 2番目以降の要素の取り出し</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="p">[,</span><span class="w"> </span><span class="p">...</span><span class="nx">other</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smalls</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
<section id="id5">
<h3>配列の要素の存在チェック<a class="headerlink" href="#id5" title="この見出しへのパーマリンク"></a></h3>
<p>以前は、要素のインデックス値を見て判断していましたが、配列に要素が入っているかどうかをbooleanで返す<code class="docutils literal notranslate"><span class="pre">includes()</span></code>メソッドが入ったので、積極的にこれを使っていきましょう。</p>
<div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-text">要素の存在チェック</span><a class="headerlink" href="#id17" title="このコードへのパーマリンク"></a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">places</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;小岩駅&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;小浜市&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;小倉駅&quot;</span><span class="p">];</span><span class="w"></span>

<span class="c1">// 旧: indexOfを利用</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">places</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s2">&quot;小淵沢&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 見つかった！</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 新: includesを利用</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">places</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s2">&quot;小淵沢&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 見つかった！</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
<section id="id6">
<h3>配列の加工<a class="headerlink" href="#id6" title="この見出しへのパーマリンク"></a></h3>
<p>配列の加工は、他言語の習熟者がJavaScriptを学ぶときにつまづくポイントでした。
<code class="docutils literal notranslate"><span class="pre">splice()</span></code>という要素の削除と追加を一度に行う謎のメソッドを使ってパズルのように配列を加工していました。
配列のメソッドによっては、配列そのものを変更したり、新しい配列を返したりが統一されていないのも難解さを増やしているポイントです。
スプレッド構文を使うと標準文法の範囲内でこのような加工ができます。
さきほどのスプレッド構文は左辺用でしたが、こちらは右辺で配列の中身を展開します。</p>
<p>近年のJavaScriptでは関数型言語のテクニックを借りてきてバグの少ないコードにしよう、という動きがあります。
その1つが、配列やオブジェクトを加工していくのではなく、値が変更されたコピーを別に作って、最後にリプレースするという方法です。
<code class="docutils literal notranslate"><span class="pre">splice()</span></code>は対象の配列を変更してしまいますが、スプレッド構文を使うと、この方針に沿ったコーディングがしやすくなります。
配列のコピーも簡単にできます。</p>
<div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text">配列の加工</span><a class="headerlink" href="#id18" title="このコードへのパーマリンク"></a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">smalls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">  </span><span class="s2">&quot;小動物&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s2">&quot;小型車&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s2">&quot;小論文&quot;</span><span class="w"></span>
<span class="p">];</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">others</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">  </span><span class="s2">&quot;小市民&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s2">&quot;小田急&quot;</span><span class="w"></span>
<span class="p">];</span><span class="w"></span>


<span class="c1">// 旧: 3番目の要素を削除して、1つの要素を追加しつつ、他の配列と結合</span><span class="w"></span>
<span class="nx">smalls</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;小心者&quot;</span><span class="p">);</span><span class="w"></span>
<span class="c1">// [ &#39;小動物&#39;, &#39;小型車&#39;, &#39;小心者&#39; ]</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">newSmalls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smalls</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">others</span><span class="p">);</span><span class="w"></span>
<span class="c1">// [ &#39;小動物&#39;, &#39;小型車&#39;, &#39;小心者&#39;, &#39;小市民&#39;, &#39;小田急&#39; ]</span><span class="w"></span>

<span class="c1">// 新: スプレッド構文で同じ操作をする</span><span class="w"></span>
<span class="c1">//     先頭要素の削除の場合、分割代入を使えばslice()も消せます</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">newSmalls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">smalls</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">),</span><span class="w"> </span><span class="s2">&quot;小心者&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">others</span><span class="p">]</span><span class="w"></span>
<span class="c1">// [ &#39;小動物&#39;, &#39;小型車&#39;, &#39;小心者&#39;, &#39;小市民&#39;, &#39;小田急&#39; ]</span><span class="w"></span>

<span class="c1">// 旧: 配列のコピー</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Array</span><span class="p">.</span><span class="kr">from</span><span class="p">(</span><span class="nx">smalls</span><span class="p">);</span><span class="w"></span>

<span class="c1">// 新: スプレッド構文で配列のコピー</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">smalls</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
<section id="id7">
<h3>配列のソート<a class="headerlink" href="#id7" title="この見出しへのパーマリンク"></a></h3>
<p>配列は<code class="docutils literal notranslate"><span class="pre">sort()</span></code>メソッドを使います。これはインプレースで、その配列を変更します。ソートをそのまま実行すると、中の要素をすべて文字列化した上で、辞書順でソートします。</p>
<div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-text">デフォルトでは文字列としてソートする</span><a class="headerlink" href="#id19" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">30</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">200</span><span class="p">];</span><span class="w"></span>

<span class="nx">numbers</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span><span class="w"></span>
<span class="c1">// 1, 200, 30</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>数値が入っている場合に、期待と異なる動作をします。比較関数を引数に渡し、0より小さい数値（左辺を左側に）、0（等価）、0より大きい数値（左辺を右側に移動）を返すことで要素の並び替えのルールを設定できます。オブジェクトの場合はどのキーを使うかなども比較関数で吸収します。左辺が小さい時に負の数を返せば昇順に、逆を返せば降順になります。</p>
<div class="literal-block-wrapper docutils container" id="id20">
<div class="code-block-caption"><span class="caption-text">ソート関数を渡す</span><a class="headerlink" href="#id20" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">30</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">200</span><span class="p">];</span><span class="w"></span>
<span class="nx">numbers</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">b</span><span class="p">);</span><span class="w"></span>
<span class="c1">// 1, 30, 200</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">stations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;池袋&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">users</span><span class="o">:</span><span class="w"> </span><span class="kt">558623</span><span class="p">},</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;新宿&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">users</span><span class="o">:</span><span class="w"> </span><span class="kt">775386</span><span class="p">},</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;渋谷&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">users</span><span class="o">:</span><span class="w"> </span><span class="kt">366128</span><span class="p">},</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;東京&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">users</span><span class="o">:</span><span class="w"> </span><span class="kt">462589</span><span class="p">}</span><span class="w"></span>
<span class="p">];</span><span class="w"></span>
<span class="c1">// 駅の利用者数でソート</span><span class="w"></span>
<span class="nx">stations</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">a</span><span class="p">.</span><span class="nx">users</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">users</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>複数の条件でソートしたい場合は、if文を重ねて書いていってもいいのですが、同値条件が抜けたりしがちなので、いったん全て-1, 0, 1にしておいて、足し合わせて総合スコアを計算する方がミスが減りますし、条件の入れ替えはしやすいでしょう。</p>
<div class="literal-block-wrapper docutils container" id="id21">
<div class="code-block-caption"><span class="caption-text">複合条件でソート</span><a class="headerlink" href="#id21" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">stations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;大手町&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">lines</span><span class="o">:</span><span class="w"> </span><span class="kt">5</span><span class="p">,</span><span class="w"> </span><span class="nx">yomi</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;おおてまち&quot;</span><span class="p">},</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;飯田橋&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">lines</span><span class="o">:</span><span class="w"> </span><span class="kt">7</span><span class="p">,</span><span class="w"> </span><span class="nx">yomi</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;いいだばし&quot;</span><span class="p">},</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;永田町&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">lines</span><span class="o">:</span><span class="w"> </span><span class="kt">5</span><span class="p">,</span><span class="w"> </span><span class="nx">yomi</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ながたちょう&quot;</span><span class="p">},</span><span class="w"></span>
<span class="p">];</span><span class="w"></span>

<span class="kd">function</span><span class="w"> </span><span class="nx">cmpNum</span><span class="p">(</span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kd">function</span><span class="w"> </span><span class="nx">cmpStr</span><span class="p">(</span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// 乗り入れ本数→読みでソート</span><span class="w"></span>
<span class="nx">stations</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">lineScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">cmpNum</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">lines</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">lines</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">yomiScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">cmpStr</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">yomi</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">yomi</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// わかりやすく10倍しているが、2倍でもOK</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">lineScore</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">yomiScore</span><span class="p">;</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>非破壊のソートはないので、元の配列を変更せずにソートした結果だけを得たい場合は、前節のスプレッド構文を組み合わせて行います。</p>
<div class="literal-block-wrapper docutils container" id="id22">
<div class="code-block-caption"><span class="caption-text">非破壊ソート</span><a class="headerlink" href="#id22" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 駅の利用者数でソート</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">sorted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">stations</span><span class="p">].</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">a</span><span class="p">.</span><span class="nx">users</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">users</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
<section id="for-of">
<h3>ループは<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">of</span></code>を使う<a class="headerlink" href="#for-of" title="この見出しへのパーマリンク"></a></h3>
<p>ループの書き方は大きくわけて3通りあります。
C言語由来のループは昔からあるものですがループ変数が必要です。
<code class="docutils literal notranslate"><span class="pre">forEach()</span></code>はその後ES5で追加されましたが、その後は言語仕様のアップデートとともに<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">of</span></code>構文が追加されました。
この構文は<code class="docutils literal notranslate"><span class="pre">Array</span></code>, <code class="docutils literal notranslate"><span class="pre">Set</span></code>, <code class="docutils literal notranslate"><span class="pre">Map</span></code>、<code class="docutils literal notranslate"><span class="pre">String</span></code>などの繰り返し可能（iterable）オブジェクトに対してループします。
配列の場合で、インデックス値が欲しい場合は、<code class="docutils literal notranslate"><span class="pre">entries()</span></code>メソッドを使います。
関数型主義的なスタイルで統一するために、<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">of</span></code> を禁止して<code class="docutils literal notranslate"><span class="pre">forEach()</span></code>のみを使うというコーディング標準を規定している会社もあります（Airbnb）。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">iterable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;小金井&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;小淵沢&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;小矢部&quot;</span><span class="p">];</span><span class="w"></span>

<span class="c1">// 旧: C言語由来のループ</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">iterable</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">iterable</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 中: forEach()ループ</span><span class="w"></span>
<span class="nx">iterable</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>

<span class="c1">// 新: for ofループで配列のインデックスが欲しい</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">iterable</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// 要素のみ欲しいときは for (const value of iterable)</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>この <code class="docutils literal notranslate"><span class="pre">entries()</span></code> メソッドは、出力ターゲットをES2015以上にしないと動作しません。
次のようなエラーがでます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// error TS2339: Property &#39;entries&#39; does not exist on type &#39;string[]&#39;.</span><span class="w"></span>
</pre></div>
</div>
<p>Polyfillを使うことで対処もできますが、Polyfillを使わない対処方法としては、 <code class="docutils literal notranslate"><span class="pre">forEach()</span></code> を使う（2つめの引数がインデックス）、旧来のループを使うしかありません。</p>
</div>
<p>速度の面で言えば、旧来の <code class="docutils literal notranslate"><span class="pre">for</span></code> ループが最速です。 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">of</span></code> や <code class="docutils literal notranslate"><span class="pre">forEach()</span></code> は、ループ1周ごとに関数呼び出しが挟まるため、実行コストが多少上乗せされます。
といっても、ゲームの座標計算で1フレームごとに数万要素のループを回さなければならない、といったケース以外ではほぼ気にする必要はないでしょう。</p>
<p><code class="docutils literal notranslate"><span class="pre">forEach()</span></code>、<code class="docutils literal notranslate"><span class="pre">map()</span></code>などのメソッドは関数型プログラミングの章でも紹介します。</p>
</section>
<section id="iterable">
<h3>iterableとイテレータ<a class="headerlink" href="#iterable" title="この見出しへのパーマリンク"></a></h3>
<p>前節の最後に <code class="docutils literal notranslate"><span class="pre">entries()</span></code> メソッドが出てきました。これは、一度のループごとに、インデックスと値のタプルを返すイテレータを返します。
配列のループのときに、インデックスと値を一緒に返すときにこのイテレータが登場しています。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;c&quot;</span><span class="p">];</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;c&quot;</span><span class="p">]];</span><span class="w"></span>

<span class="c1">// この2つの結果は同じ</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">a</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>この <code class="docutils literal notranslate"><span class="pre">entries()</span></code> は何者なんでしょうか？正解は、 <code class="docutils literal notranslate"><span class="pre">next()</span></code> というメソッドを持つイテレータと呼ばれるオブジェクトを返すメソッドです。
この <code class="docutils literal notranslate"><span class="pre">next()</span></code> は、配列の要素と、終了したかどうかの boolean値を返します。
イテレータ（厳密には外部イテレータと呼ばれる）はJavaやPython、C++ではおなじみのものです。</p>
<p>上記の <code class="docutils literal notranslate"><span class="pre">b</span></code> のように全部の要素を持つ二重配列を作ってしまえばこのようなイテレータというものは必要ありませんが、その場合、要素数が多くなればなるほど、コピーに時間がかかってループが回る前の準備が遅くなる、という欠点を抱えることになります。そのため、このイテレータという要素を返すオブジェクトを使い、全コピーを防いでいます。</p>
<p>オブジェクトにループの要素を取り出すメソッド（<code class="docutils literal notranslate"><span class="pre">&#64;&#64;iterator</span></code>）があるオブジェクトはiterableなオブジェクトです。
繰り返し処理に対する約束事なので「iterableプロトコル」と呼ばれます。
このメソッドはイテレータを返します。
配列は、 <code class="docutils literal notranslate"><span class="pre">&#64;&#64;iterator</span></code> 以外にも、 <code class="docutils literal notranslate"><span class="pre">keys()</span></code> 、 <code class="docutils literal notranslate"><span class="pre">values()</span></code> 、 <code class="docutils literal notranslate"><span class="pre">entries()</span></code> と、イテレータを返すメソッドが合計4つあります。</p>
<p><code class="docutils literal notranslate"><span class="pre">for...of</span></code>ループなどは、このプロトコルにしたがってループを行います。
これ以外にも、分割代入や、スプレッド構文など、本特集で紹介した機能がこのiterableプロトコルを土台に提供されています。</p>
<p><code class="docutils literal notranslate"><span class="pre">Array</span></code>, <code class="docutils literal notranslate"><span class="pre">Set</span></code>, <code class="docutils literal notranslate"><span class="pre">Map</span></code>、<code class="docutils literal notranslate"><span class="pre">String</span></code>　などのオブジェクトがこのプロトコルを提供していますが、将来的に出てくるデータ構造もこのプロトコルをサポートするでしょう。
また、自作することもできます。</p>
<p>イテレータはループするときには問題ありませんが、任意の位置の要素へのアクセスなどは不便です。
イテレータから配列に変換したい場合は <code class="docutils literal notranslate"><span class="pre">Array.from()</span></code> メソッドか、スプレッド構文が使えます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// こうする</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Array</span><span class="p">.</span><span class="kr">from</span><span class="p">(</span><span class="nx">iterable</span><span class="p">);</span><span class="w"></span>

<span class="c1">// これもできる</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">iterable</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>イテレータはES2015以降にしか存在しないため、スプレッド構文を使ってイテレータを配列に変換するのは、出力ターゲットがES2015以上でなければなりません。</p>
<blockquote>
<div><div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">iterable</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</div>
</section>
<section id="id8">
<h3>読み込み専用の配列<a class="headerlink" href="#id8" title="この見出しへのパーマリンク"></a></h3>
<p>TypeScriptの「<code class="docutils literal notranslate"><span class="pre">const</span></code>」は変数の再代入をさせない、というガードにはなりますが、C++のように、「変更不可」にはできません。TypeScriptにはこれには別のキーワード、<code class="docutils literal notranslate"><span class="pre">readonly</span></code>が提供されています。型の定義の前に<code class="docutils literal notranslate"><span class="pre">readonly</span></code>を付与するか、リテラルの後ろに<code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">const</span></code>をつけると読み込み専用になります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 型につける場合はreadonly</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="kt">readonly</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">];</span><span class="w"></span>
<span class="c1">// 値やリテラルに付ける場合はas const</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">]</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="kd">const</span><span class="p">;</span><span class="w"></span>
<span class="nx">a</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Index signature in type &#39;readonly number[]&#39; only permits reading.</span><span class="w"></span>
</pre></div>
</div>
<p>読み込み専用の配列は普通の変更可能な配列よりは厳しい制約となります。変更可能な配列は、readonlyな配列の変数や引数には渡すことができます。逆に読み込み専用の配列を変更可能な配列の変数に格納したり関数の引数に渡したりしようとするとエラーになります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">readonlyArray</span><span class="o">:</span><span class="w"> </span><span class="kt">readonly</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">mutableArray</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">];</span><span class="w"></span>

<span class="kd">function</span><span class="w"> </span><span class="nx">acceptReadonlyArray</span><span class="p">(</span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="kt">readonly</span><span class="w"> </span><span class="kt">number</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">function</span><span class="w"> </span><span class="nx">acceptMutableArray</span><span class="p">(</span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// OK</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">readonlyVar</span><span class="o">:</span><span class="w"> </span><span class="kt">readonly</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mutableArray</span><span class="p">;</span><span class="w"></span>

<span class="c1">// NG</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">mutableVar</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">readonlyArray</span><span class="p">;</span><span class="w"></span>
<span class="c1">// The type &#39;readonly number[]&#39; is &#39;readonly&#39; and cannot be assigned to the mutable type &#39;number[]&#39;.</span><span class="w"></span>

<span class="c1">// OK</span><span class="w"></span>
<span class="nx">acceptReadonlyArray</span><span class="p">(</span><span class="nx">mutableArray</span><span class="p">);</span><span class="w"></span>

<span class="c1">// NG</span><span class="w"></span>
<span class="nx">acceptMutableArray</span><span class="p">(</span><span class="nx">readonlyArray</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Argument of type &#39;readonly number[]&#39; is not assignable to parameter of type &#39;number[]&#39;.</span><span class="w"></span>
<span class="c1">// The type &#39;readonly number[]&#39; is &#39;readonly&#39; and cannot be assigned to the mutable type &#39;number[]&#39;.</span><span class="w"></span>
</pre></div>
</div>
<p>内部的には同じ配列ではありますので、型アサーションで<code class="docutils literal notranslate"><span class="pre">readonly</span></code>なしのものにキャストすれば格納したり呼び出し時に渡したりは可能です。しかし、C/C++ではいわゆる「const外し」はプログラムの安全性を脅かす邪悪な行為として忌み嫌われます。C/C++の場合は組み込み機器で、読み込みしかできないメモリ領域にデータがおかれることもあり、動作が未定義で不正な挙動がおきうる、という意味ではTypeScriptよりもはるかに危険な行為ではありますが、「不変だと思っていた」変数がいつの間にかに書き換わっていたりして、開発者を混乱させる点では同じです。</p>
<p>この<code class="docutils literal notranslate"><span class="pre">readonly</span></code>を無理やり外したりせずに自然と使うためには、上から下までコード全体で<code class="docutils literal notranslate"><span class="pre">readonly</span></code>を使うように徹底するか、あるいは、まったく使わないかの二者択一になります。利用しているライブラリが<code class="docutils literal notranslate"><span class="pre">readonly</span></code>を使っているかというと、使っていないことが多いので、外部ライブラリとの接点では必ず<code class="docutils literal notranslate"><span class="pre">readonly</span></code>外しが必要になるかもしれません。ここはプロジェクト全体での意思統一が必要になる場面となります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">mutableVar</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">readonlyArray</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="kt">number</span><span class="p">[];</span><span class="w"></span>
<span class="nx">acceptMutableArray</span><span class="p">(</span><span class="nx">readonlyArray</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="kt">number</span><span class="p">[]);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="typescript">
<h3>TypeScriptと配列<a class="headerlink" href="#typescript" title="この見出しへのパーマリンク"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">of</span></code> には速度のペナルティがあるということを紹介しました。しかし、TypeScriptを使っている場合には少し恩恵があります。</p>
<p>TypeScriptを使っていると、ES5への出力の場合型情報を見て、 <code class="docutils literal notranslate"><span class="pre">Array</span></code> 型の <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">of</span></code> ループの場合、旧来の最速の <code class="docutils literal notranslate"><span class="pre">for</span></code> ループのJavaScriptコードが生成されますので、速度上のペナルティがまったくない状態で、最新の構文が使えるメリットがあります。また、ChromeなどのJavaScriptエンジンの場合は、同一の型の要素だけを含む配列の場合、特別な最適化を行います。</p>
<p>TypeScriptを使うと、型情報がついて実装が簡単になるだけではなく、速度のメリットもあります。</p>
</section>
<section id="id9">
<h3>配列のようで配列でない、ちょっと配列なオブジェクト<a class="headerlink" href="#id9" title="この見出しへのパーマリンク"></a></h3>
<p>TypeScriptがメインターゲットとしてるブラウザ環境では、配列に似たオブジェクトがあります。HTMLのDOMを操作したときに得られる、<code class="docutils literal notranslate"><span class="pre">HTMLCollection</span></code>と、<code class="docutils literal notranslate"><span class="pre">NodeList</span></code>です。前者は<code class="docutils literal notranslate"><span class="pre">document.forms</span></code>などでフォームを取得してきたときにも得られます。どちらも<code class="docutils literal notranslate"><span class="pre">.length</span></code>で長さが取得でき、インデックスアクセスができるため、一見配列のようですが、配列よりもメソッドがかなり少なくなっています。<code class="docutils literal notranslate"><span class="pre">NodeList</span></code>は<code class="docutils literal notranslate"><span class="pre">forEach()</span></code>はありますが、<code class="docutils literal notranslate"><span class="pre">HTMLCollection</span></code>にはありません。<code class="docutils literal notranslate"><span class="pre">map()</span></code>や<code class="docutils literal notranslate"><span class="pre">some()</span></code>はどちらにもありません。</p>
<p>どちらもイテレータは利用できますので、次のようなコードは利用できます。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">..</span> <span class="pre">of</span></code>ループ</p></li>
<li><p>スプレッド構文</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Array.from()</span></code>で配列に変換してから各種配列のメソッドを利用</p></li>
</ul>
</section>
</section>
<section id="id10">
<h2>オブジェクト<a class="headerlink" href="#id10" title="この見出しへのパーマリンク"></a></h2>
<p>オブジェクトは、JavaScriptのコアとなるデータですが、クラスなどを定義しないで、気軽にまとまったデータを扱うときに使います。
配列は要素へのアクセス方法がインデックス（数値）でしたが、オブジェクトの場合は文字列です。
キー名が変数などで使える文字だけで構成されている場合は、名前をそのまま記述できますが、空白文字やマイナスなどを含む場合にはダブルクオートやシングルクオートでくくります。
また、キー名に変数を書く場合は <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">]</span></code> でくくります。</p>
<div class="literal-block-wrapper docutils container" id="id23">
<div class="code-block-caption"><span class="caption-text">オブジェクト</span><a class="headerlink" href="#id23" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 定義はキー、コロン(:)、値を書く。要素間は改行</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;favorite drink&#39;</span><span class="p">;</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;小動物&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nx">favorite</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;小籠包&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s1">&#39;home town&#39;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;神奈川県警のいるところ&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ストロングゼロ&quot;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// 参照は `.`+名前、もしくは [名前]</span><span class="w"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">smallAnimal</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span><span class="w"> </span><span class="c1">// 小動物</span><span class="w"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">smallAnimal</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ストロングゼロ</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>おおきなプログラムをきちんと書く場合には、次の章で紹介するクラスを使うべきですが、次のようなクラスを定義するまでもない場面で出てきます。</p>
<ul class="simple">
<li><p>Webサービスのリクエストやレスポンス</p></li>
<li><p>関数のオプショナルな引数</p></li>
<li><p>複数の情報を返す関数</p></li>
<li><p>複数の情報を返す非同期処理</p></li>
</ul>
<section id="json-javascript-object-notation">
<h3>JSON（JavaScript Object Notation）<a class="headerlink" href="#json-javascript-object-notation" title="この見出しへのパーマリンク"></a></h3>
<p>オブジェクトがよく出てくる文脈は「JSON」です。JSONというのはデータ交換用フォーマットで、つまりは文字列です。
プレーンテキストであり、書きやすく読みやすい（XMLやSOAPと比べて）こともありますし、JavaScriptでネイティブで扱えるため、API通信で使われるデータフォーマットとしてはトップシェアを誇ります。</p>
<p>JSONをパースすると、オブジェクトと配列で階層構造になったデータができあがります。
通信用のライブラリでは、パース済みの状態でレスポンスが返ってきたりするため、正確ではないですが、このオブジェクト/配列も便宜上、JSONと呼ぶこともあります。</p>
<div class="literal-block-wrapper docutils container" id="id24">
<div class="code-block-caption"><span class="caption-text">JSONとオブジェクト</span><a class="headerlink" href="#id24" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 最初の引数にオブジェクトや配列、文字列などを入れる</span><span class="w"></span>
<span class="c1">// 2つめの引数はデータ変換をしたいときの変換関数（ログ出力からパスワードをマスクしたいなど）</span><span class="w"></span>
<span class="c1">//   省略可能。通常はnull</span><span class="w"></span>
<span class="c1">// 3つめは配列やオブジェクトでインデントするときのインデント幅</span><span class="w"></span>
<span class="c1">//   省略可能。省略すると改行なしの1行で出力される</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">smallAnimal</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">);</span><span class="w"></span>

<span class="c1">// これは複製されて出てくるので、元のsmallAnimalとは別物</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">smallAnimal2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>JSONはJavaScript/TypeScriptのオブジェクト定義よりもルールが厳密です。
たとえば、キーは必ずダブルクオートでくくらなければなりませんし、配列やオブジェクトの末尾に不要なカンマがあるとエラーになります。
その場合はJSON.parse()の中で <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code> 例外が発生します。
特に、JSONを便利だからとマスターデータとして使っていて、非プログラマーの人に、編集してもらったりしたときによく発生します。
あとは、JSONレスポンスを期待しているウェブサービスの時に、サーバー側でエラーが発生して、 <code class="docutils literal notranslate"><span class="pre">Forbidden</span></code> という文字列が返ってきた場合（403エラー時のボディ）にも発生します。</p>
<div class="literal-block-wrapper docutils container" id="id25">
<div class="code-block-caption"><span class="caption-text">JSONパースのエラー</span><a class="headerlink" href="#id25" title="このコードへのパーマリンク"></a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SyntaxError: Unexpected token n in JSON at position 1
</pre></div>
</div>
</div>
</section>
<section id="id11">
<h3>オブジェクトからのデータの取り出し<a class="headerlink" href="#id11" title="この見出しへのパーマリンク"></a></h3>
<p>オブジェクトの場合も配列同様、分割代入でまとめて取り出せます。
また、要素がなかったときにデフォルト値を設定したり、指定された要素以外のオブジェクトを抜き出すことが可能です。
注意点としては、まとめて取り出す場合の変数名は、必ずオブジェクトのキー名になります。
関数の返値や、後述の<code class="docutils literal notranslate"><span class="pre">Promise</span></code>では、この記法のおかげで気軽に複数の情報をまとめて返せます。</p>
<div class="literal-block-wrapper docutils container" id="id26">
<div class="code-block-caption"><span class="caption-text">オブジェクトの要素の取り出し</span><a class="headerlink" href="#id26" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;小動物&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nx">favorite</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;小籠包&quot;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// 旧: 一個ずつ取り出す</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">favorite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">.</span><span class="nx">favorite</span><span class="p">;</span><span class="w"></span>
<span class="c1">// 旧: 存在しない場合はデフォルト値を設定</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">.</span><span class="nx">age</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">smallAnimal.age</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">3</span><span class="p">;</span><span class="w"></span>

<span class="c1">// 新: まとめて取り出し。デフォルト値も設定可能</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">favorite</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="o">=</span><span class="mf">3</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">;</span><span class="w"></span>
<span class="c1">// 新: name以外の要素の取り出し</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">other</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>ES2020で追加された機能として、オプショナルチェイニングがあります。TypeScriptでも3.7から導入されました。TypeScriptでは、変数の型として、文字列だけでなく、場合によっては無効な値として<code class="docutils literal notranslate"><span class="pre">null</span></code>や<code class="docutils literal notranslate"><span class="pre">undefined</span></code>が入る可能性がある、といったバリエーションを持たせることができます。型定義の話は<a class="reference internal" href="typing.html"><span class="doc">基本的な型付け</span></a>で触れるので、先行した説明になりますが、例えば次の定義は<code class="docutils literal notranslate"><span class="pre">smallAnimal</span></code>自身がオブジェクト、もしくは<code class="docutils literal notranslate"><span class="pre">null</span></code>となりえますし、<code class="docutils literal notranslate"><span class="pre">favorite</span></code>というメンバーも<code class="docutils literal notranslate"><span class="pre">undefined</span></code>になりえるという意味になります。</p>
<p>この場合、深い階層にアクセスする場合は、一つずつ、<code class="docutils literal notranslate"><span class="pre">null</span></code>や<code class="docutils literal notranslate"><span class="pre">undefined</span></code>になりえるところでチェックを行っていました。<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>演算子が、一つでも途中にfalseyな値があると評価を止める、そうでなければ最後の値を返すという挙動を持っているため、それを活用したコーディングが行われていました。</p>
<p>オプショナルチェイニングは同じことを実現する演算子として<code class="docutils literal notranslate"><span class="pre">?.</span></code>が導入されました。途中でnullish（<code class="docutils literal notranslate"><span class="pre">null</span></code>か<code class="docutils literal notranslate"><span class="pre">undefined</span></code>）な値があると、式全体の評価結果が<code class="docutils literal notranslate"><span class="pre">undefined</span></code>になります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">favorite?</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;小動物&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nx">favorite</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;小籠包&quot;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// 旧: 一個ずつ確認してアクセスし、大文字の好物を取得</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">favorite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">.</span><span class="nx">favorite</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">.</span><span class="nx">favorite</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="w"></span>

<span class="c1">// 新: 一個ずつ確認してアクセスし、大文字の好物を取得</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">favorite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="o">?</span><span class="p">.</span><span class="nx">favorite</span><span class="o">?</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id12">
<h3>オブジェクトの要素の加工<a class="headerlink" href="#id12" title="この見出しへのパーマリンク"></a></h3>
<p>JavaScriptではオブジェクトがリテラルで作成できるデータ構造として気軽に利用されます。
オブジェクトの加工（コピーや結合）も配列同様にスプレッド構文で簡単にできます。</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;小動物&quot;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">attributes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">job</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;小説家&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nx">nearStation</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;小岩駅&quot;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 最古: オブジェクトをコピー</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="nx">key1</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">smallAnimal</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">copy</span><span class="p">[</span><span class="nx">key1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">[</span><span class="nx">key1</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 旧: Object.assign()を使ってコピー</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">);</span><span class="w"></span>

<span class="c1">// 新: スプレッド構文でコピー</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{...</span><span class="nx">smallAnimal</span><span class="p">};</span><span class="w"></span>

<span class="c1">// 最古: オブジェクトをマージ</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">merged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="nx">key1</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">smallAnimal</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">merged</span><span class="p">[</span><span class="nx">key1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">[</span><span class="nx">key1</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="nx">key2</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">attributes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key2</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">merged</span><span class="p">[</span><span class="nx">key2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">attributes</span><span class="p">[</span><span class="nx">key2</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 旧: Object.assign()を使ってオブジェクトをマージ</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">merged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="p">,</span><span class="w"> </span><span class="nx">attributes</span><span class="p">);</span><span class="w"></span>

<span class="c1">// 新: スプレッド構文でマージ</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">merged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{...</span><span class="nx">smallAnimal</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">attributes</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="map">
<h3>辞書用途はオブジェクトではなくて<code class="docutils literal notranslate"><span class="pre">Map</span></code>を使う<a class="headerlink" href="#map" title="この見出しへのパーマリンク"></a></h3>
<p>ES2015では、単なる配列以外にも、<code class="docutils literal notranslate"><span class="pre">Map</span></code>/<code class="docutils literal notranslate"><span class="pre">Set</span></code>などが増えました。これらは子供のデータをフラットにたくさん入れられるデータ構造です。
これも配列と同じiterableですので、同じ流儀でループできます。
古のコードはオブジェクトを、他言語の辞書やハッシュのようにつかっていましたが、今時は<code class="docutils literal notranslate"><span class="pre">Map</span></code>を使います。
他の言語のようにリテラルで簡単に初期化できないのは欠点ですが、キーと値を簡単に取り出してループできるほか、キーだけでループ（<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(const</span> <span class="pre">key</span> <span class="pre">of</span> <span class="pre">map.keys())</span></code>）, 値だけでループ（<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(const</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">map.values())</span></code>）も使えます。</p>
<p>辞書用途で見た場合の利点は、オブジェクトはキーの型に文字列しか入れることができませんが、 <code class="docutils literal notranslate"><span class="pre">Map</span></code> や <code class="docutils literal notranslate"><span class="pre">Set</span></code> では <code class="docutils literal notranslate"><span class="pre">number</span></code> なども扱えます。</p>
<p>オブジェクトは、データベースでいうところのレコード（1つのオブジェクトはいつも固定の名前がある）として使い、 <code class="docutils literal notranslate"><span class="pre">Map</span></code> はキーが可変の連想配列で、値の型が常に一定というケースで使うと良いでしょう。</p>
<p><code class="docutils literal notranslate"><span class="pre">WeakMap</span></code>や <code class="docutils literal notranslate"><span class="pre">WeakSet</span></code>という弱参照のキャッシュに使えるコレクションもありますし、ブラウザで使えるウェブアクセスの<code class="docutils literal notranslate"><span class="pre">Fetch</span></code>APIの<code class="docutils literal notranslate"><span class="pre">Headers</span></code>クラスも似たAPIを提供しています。
これらのクラスに慣れておくと、コレクションを扱うコードが自在に扱えるようになるでしょう。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 旧: オブジェクトを辞書代わりに</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="s2">&quot;五反田&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;約束の地&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s2">&quot;戸越銀座&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;TGSGNZ&quot;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot; : &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">map</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 新: Mapを利用</span><span class="w"></span>
<span class="c1">// ``&lt;キーの型、 値の型&gt;`` で明示的に型を指定すると</span><span class="w"></span>
<span class="c1">// ``set()`` 時に型違いのデータを入れようとするとチェックできるし、</span><span class="w"></span>
<span class="c1">// ループなどで値を取り出しても型情報が維持されます</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Map</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">([</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="s2">&quot;五反田&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;約束の地&quot;</span><span class="p">],</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="s2">&quot;戸越銀座&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;TGSGNZ&quot;</span><span class="p">]</span><span class="w"></span>
<span class="p">]);</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb"> : </span><span class="si">${</span><span class="nx">value</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><code class="docutils literal notranslate"><span class="pre">Map</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Set</span></code> はES2015以降に導入されたクラスであるため、出力ターゲットをこれよりも新しくするか、ライブラリに登録した上でPolyfillを使うしかありません。</p>
</div>
</section>
<section id="id13">
<h3>TypeScriptとオブジェクト<a class="headerlink" href="#id13" title="この見出しへのパーマリンク"></a></h3>
<p>オブジェクトは、プロトタイプ指向というJavaScriptの柔軟性をささえる重要な部品です。
一方、TypeScriptはなるべく静的に型をつけて行く事で、コンパイル時にさまざまなチェックが行えるようになり不具合を見つけることができます。オブジェクトの型の定義については<a class="reference internal" href="typing.html"><span class="doc">基本的な型付け</span></a>の章で紹介します。</p>
<p>型定義をすると、プロパティの名前のスペルミスであったり、違う型を入れてしまうことが減ります。エラーチェックのコードを実装する手間も減るでしょう。</p>
</section>
<section id="id14">
<h3>読み込み専用のオブジェクト<a class="headerlink" href="#id14" title="この見出しへのパーマリンク"></a></h3>
<p>配列は<code class="docutils literal notranslate"><span class="pre">readonly</span></code>や<code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">const</span></code>をつけて読み込み専用にできましたが、オブジェクトも同様のことができます。ただし、<code class="docutils literal notranslate"><span class="pre">readonly</span></code>キーワードではできず、型ユーティリティの<code class="docutils literal notranslate"><span class="pre">Readonly&lt;&gt;</span></code>を使います。これには、型を定義しておく必要があります。これ以外にも、フィールドごとに<code class="docutils literal notranslate"><span class="pre">readonly</span></code>を付与することもで可能です。あるいは、型ではなく、値の最後に<code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">const</span></code>を付与します。前節でも触れましたが、これも詳しくは<a class="reference internal" href="typing.html"><span class="doc">基本的な型付け</span></a>の章で紹介します。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nx">age</span><span class="o">:</span><span class="w">  </span><span class="kt">number</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">u</span><span class="o">:</span><span class="w"> </span><span class="kt">Readonly</span><span class="o">&lt;</span><span class="nx">User</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;shibukawa&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">39</span><span class="p">};</span><span class="w"></span>

<span class="c1">// こちらでも良い</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;shibukawa&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">39</span><span class="p">}</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="kd">const</span><span class="p">;</span><span class="w"></span>

<span class="c1">// NG</span><span class="w"></span>
<span class="nx">u</span><span class="p">.</span><span class="nx">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">17</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Cannot assign to &#39;age&#39; because it is a read-only property.</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="id15">
<h2>まとめ<a class="headerlink" href="#id15" title="この見出しへのパーマリンク"></a></h2>
<p>JavaScriptの2大複合型の配列とオブジェクトを紹介しました。また、オブジェクトの関連のデータ構造として <code class="docutils literal notranslate"><span class="pre">Map</span></code> や <code class="docutils literal notranslate"><span class="pre">Set</span></code> も紹介しました。</p>
<p>Javaと比べると、TypeScriptで実装する場合、同じようなものを実装する場合にもクラス定義の数は減るでしょう。ちょっとしたデータを格納するデータ構造などは、これらの型を使って定義なしで使うことが多いからです。Javaからやってくると、これらの型を乱用しているように見えて不安になるかもしれません。しかし、TypeScriptを使えば、型推論やインラインでの明示的な型定義によって、これらの型でもきちんとしたチェックが行われるようになります。不安はあるかもしれませんが、安全にコーディングができます。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="primitive.html" class="btn btn-neutral float-left" title="プリミティブ型" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="syntax.html" class="btn btn-neutral float-right" title="基本的な構文" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020, Future Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>