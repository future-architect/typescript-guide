

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>基本的な型付け &mdash; 仕事ですぐに使えるTypeScript  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="関数" href="function.html" />
    <link rel="prev" title="基本的な構文" href="syntax.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> 仕事ですぐに使えるTypeScript
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">TypeScriptの世界を知る</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preface.html">前書き</a></li>
<li class="toctree-l1"><a class="reference internal" href="ecosystem.html">Node.jsエコシステムを体験しよう</a></li>
</ul>
<p class="caption"><span class="caption-text">TypeScriptの書き方</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="variable.html">変数</a></li>
<li class="toctree-l1"><a class="reference internal" href="primitive.html">プリミティブ型</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">複合型</a></li>
<li class="toctree-l1"><a class="reference internal" href="syntax.html">基本的な構文</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">基本的な型付け</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#any">一番手抜きな型付け: <code class="docutils literal notranslate"><span class="pre">any</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#unknown">未知の型: <code class="docutils literal notranslate"><span class="pre">unknown</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">型に名前をつける</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">関数のレスポンスや引数で使うオブジェクトの定義</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">オブジェクトの属性の修飾: オプション、読み込み専用</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">属性名が可変のオブジェクトを扱う</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ab">AかつBでなければならない</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">タグ付き合併型: パラメータの値によって必要な属性が変わる柔軟な型定義を行う</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">型ガード</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id11">組み込みの型ガード</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">ユーザー定義の型ガード</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">型アサーション</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#keyof-mapped-type"><code class="docutils literal notranslate"><span class="pre">keyof</span></code> とMapped Type: オブジェクトのキーの文字列のみを許容する動的な型宣言</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">インタフェースを使った型定義</a></li>
<li class="toctree-l2"><a class="reference internal" href="#typescript">もしTypeScriptの型を付けるのがコストが高いと感じたら？</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">まとめ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="function.html">関数</a></li>
<li class="toctree-l1"><a class="reference internal" href="otherbuiltinobjects.html">その他の組み込み型</a></li>
<li class="toctree-l1"><a class="reference internal" href="class.html">クラス</a></li>
<li class="toctree-l1"><a class="reference internal" href="async.html">非同期処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="exception.html">例外処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="module.html">モジュール</a></li>
<li class="toctree-l1"><a class="reference internal" href="console.html"><code class="docutils literal notranslate"><span class="pre">console.log</span></code>によるログ出力</a></li>
</ul>
<p class="caption"><span class="caption-text">中級のテクニック</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="generics.html">ジェネリクス</a></li>
<li class="toctree-l1"><a class="reference internal" href="functional.html">関数型指向のプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="class2.html">クラス上級編</a></li>
<li class="toctree-l1"><a class="reference internal" href="reactive.html">リアクティブ</a></li>
<li class="toctree-l1"><a class="reference internal" href="advance.html">高度なテクニック</a></li>
</ul>
<p class="caption"><span class="caption-text">環境ごとのTips</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="prodenv.html">ソフトウェア開発の環境を考える</a></li>
<li class="toctree-l1"><a class="reference internal" href="baseenv.html">基本の環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="libenv.html">ライブラリ開発のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="clienv.html">CLIツール・ウェブサーバー作成のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="react.html">Reactの環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="vue.html">Vue.jsの環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">CI（継続的インテグレーション）環境の構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="deploy.html">成果物のデプロイ</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">使用ライブラリのバージョン管理</a></li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="recommended.html">おすすめのパッケージ・ツール</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html">貢献者</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">仕事ですぐに使えるTypeScript</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>基本的な型付け</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/typing.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>基本的な型付け<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>TypeScriptはJavaScriptに対して型をつけるという方向で仕様が作られています。
JavaScriptは動的言語の中でも、いろいろ制約がゆるく、無名関数とオブジェクトを使ってかなり柔軟なプログラミングの手法を提供してきました。
そのため、オブジェクトに対して型をつける方法についても、他のJavaなどの静的型付け言語よりもかなり複雑な機能を持っています。</p>
<p>ただし、ここに説明されている機能を駆使して完璧な型付けを行う必要があるかというと、それは時と場合によります。
たとえば、TypeScriptを使ってライブラリを作る場合、それを利用するコードもTypeScriptであれば型チェックでコンパイル時にチェックが行われます。
しかし、利用する側がJavaScriptの場合は、型によるチェックができません。エラーを見逃すことがありえます。
ユーザー数が多くなって、利用者が増えるかどうかで費用対効果を考えて、どこまで詳細に型づけを行うか決めれば良いでしょう。</p>
<p>なお、最初の変数の定義のところで、いくつか型についても紹介しました。それを少し思い出していただければ、と思います。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 型は合併型(Union Type)で複数列挙できる</span>
<span class="kd">let</span> <span class="nx">birthYear</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kt">string</span><span class="p">;</span>

<span class="c1">// 型には文字列や数値の値も設定できる</span>
<span class="kd">let</span> <span class="nx">favoriteFood</span><span class="o">:</span> <span class="s2">&quot;北極&quot;</span> <span class="o">|</span> <span class="s2">&quot;冷やし味噌&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="any">
<h2>一番手抜きな型付け: <code class="docutils literal notranslate"><span class="pre">any</span></code><a class="headerlink" href="#any" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>費用対効果を考えましょう、と言われても、意思決定の幅がわからないと、どこが良いのか決断はできません。
最初に、一番費用が少ない方法を紹介します。
それが<code class="docutils literal notranslate"><span class="pre">any</span></code>です。<code class="docutils literal notranslate"><span class="pre">any</span></code>と書けば、TypeScriptのコンパイラは、その変数のチェックをすべて放棄します。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">someFunction</span><span class="p">(</span><span class="nx">opts</span>: <span class="kt">any</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">opts</span><span class="p">.</span><span class="nx">debug</span><span class="p">);</span> <span class="c1">// debugがあるかどうかチェックしないのでエラーにならない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これを積極的に使う場面はというと、すでにJavaScriptとして動作していて実績があるコードをTypeScriptにまずは持ってくる、というケースが考えられます。
あとは、メインの引数ではなくて、挙動をコントロールするオプションの項目がかなり複雑で、型定義が複雑な場合などです。
例えば、JSONSchemaを受け取るような引数があったら、JSONSchemaのすべての仕様を満たす型定義を記述するのはかなり時間を要します。
将来やるにしても、まずはコンパイルだけは通したい、というときに使うと良いでしょう。</p>
<p>ただし、これを使うと、TypeScriptが提供する型チェックの恩恵は受けられません。<code class="docutils literal notranslate"><span class="pre">any</span></code>から型情報つきのデータにするためには後述の型ガードや型アサーションで変換しなければなりません。利用する箇所で毎回必要になります。TypeScirptの型情報は伝搬するので、なるべく早めに、データが発生する場所で型情報を付ければ、変換が不要になります。そのため、よっぽどの理由がないかぎりは<code class="docutils literal notranslate"><span class="pre">any</span></code>を使わない方がトータルの実装コストは大きく減ります。</p>
<p>それ以外だと、外部からやってくるデータなどはコンパイル時には型情報がわかりません。標準ライブラリのブラウザのサーバーアクセスAPIの<code class="docutils literal notranslate"><span class="pre">fetch</span></code>のレスポンスは<code class="docutils literal notranslate"><span class="pre">any</span></code>となっています。そのため、<code class="docutils literal notranslate"><span class="pre">fetch</span></code>のレスポンスに関しては何かしらの変換処理が必要になります。</p>
</div>
<div class="section" id="unknown">
<h2>未知の型: <code class="docutils literal notranslate"><span class="pre">unknown</span></code><a class="headerlink" href="#unknown" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">unknown</span></code> は <code class="docutils literal notranslate"><span class="pre">any</span></code> と似ています。 <code class="docutils literal notranslate"><span class="pre">unknown</span></code> 型の変数にはどのようなデータもチェックなしに入れることができます。
違うのは <code class="docutils literal notranslate"><span class="pre">unknown</span></code> の場合は、その変数を利用する場合には、型アサーションを使ってチェックを行わないとエラーになる点です。
型アサーションについてはこの章の最後で扱います。</p>
<p><code class="docutils literal notranslate"><span class="pre">unknown</span></code>はもう一箇所出てくる可能性のある場所があります。ジェネリクスを使ったクラスや関数のうち、自動で型推論で設定できなかったものは<code class="docutils literal notranslate"><span class="pre">unknown</span></code>となります。この型変数の<code class="docutils literal notranslate"><span class="pre">unknown</span></code>に関してはエラーチェックなどが行われることがなく、<code class="docutils literal notranslate"><span class="pre">any</span></code>のように振舞います。型推論で自動設定される予定の型変数が<code class="docutils literal notranslate"><span class="pre">unknown</span></code>になってしまったのであれば、コーディングのミスが発生したものと考えられます。</p>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">課題</p>
<p>事例をつける</p>
</div>
</div>
<div class="section" id="id3">
<h2>型に名前をつける<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">名前</span> <span class="pre">=</span></code> という構文を使って、型に名前をつけることができます。
名前には、通常の変数や関数名として使える名前が使えます。
ここで定義した型は、変数定義や、関数の引数などで使えます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 型は合併型で複数列挙できる</span>
<span class="nx">type</span> <span class="nx">BirthYear</span> <span class="o">=</span> <span class="kt">number</span> <span class="o">|</span> <span class="kt">string</span><span class="p">;</span>

<span class="c1">// 型には値も設定できる</span>
<span class="nx">type</span> <span class="nx">FoodMenu</span> <span class="o">=</span> <span class="s2">&quot;北極&quot;</span> <span class="o">|</span> <span class="s2">&quot;冷やし味噌&quot;</span><span class="p">;</span>

<span class="c1">// 変数や関数の引数で使える</span>
<span class="kr">const</span> <span class="nx">birthday</span>: <span class="kt">BirthYear</span> <span class="o">=</span> <span class="s2">&quot;平成&quot;</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">orderFood</span><span class="p">(</span><span class="nx">food</span>: <span class="kt">FoodMenu</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使い回しをしないのであれば型名の代わりに、すべての箇所に定義を書いていってもエラーチェックの結果は変わりません。
また、TypeScriptは型名ではなく、型の内容で比較してチェックを行うため、別名の型でも、片方は型で書いて、片方は直接書き下したケースでも問題なくチェックされます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">FoodMenu</span> <span class="o">=</span> <span class="s2">&quot;北極&quot;</span> <span class="o">|</span> <span class="s2">&quot;冷やし味噌&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">myOrder</span>: <span class="kt">FoodMenu</span> <span class="o">=</span> <span class="s2">&quot;北極&quot;</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">orderFood</span><span class="p">(</span><span class="nx">food</span><span class="o">:</span> <span class="s2">&quot;北極&quot;</span> <span class="o">|</span> <span class="s2">&quot;冷やし味噌&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">food</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">orderFood</span><span class="p">(</span><span class="nx">myOrder</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>関数のレスポンスや引数で使うオブジェクトの定義<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> はオブジェクトが持つべき属性の定義にも使えます。
属性には型をつけることができます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">favoriteBank</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">favoriteGyudon</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 変数定義時にインタフェースを指定</span>
<span class="kr">const</span> <span class="nx">person</span>: <span class="kt">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Yoichi&quot;</span><span class="p">,</span>
  <span class="nx">favoriteBank</span><span class="o">:</span> <span class="s2">&quot;Mizuho&quot;</span><span class="p">,</span>
  <span class="nx">favoriteGyudon</span><span class="o">:</span> <span class="s2">&quot;Matsuya&quot;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>このように型定義をしておくと、関数の引数などでもエラーチェックが行われ、関数の呼び出し前後での不具合発生を抑えることができます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 関数の引数がPerson型の場合</span>
<span class="nx">registerPerson</span><span class="p">({</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Yoichi&quot;</span><span class="p">,</span>
  <span class="nx">favoriteBank</span><span class="o">:</span> <span class="s2">&quot;Mizuho&quot;</span><span class="p">,</span>
  <span class="nx">favoriteGyudon</span><span class="o">:</span> <span class="s2">&quot;Matsuya&quot;</span>
<span class="p">});</span>

<span class="c1">// レスポンスがPerson型の場合</span>
<span class="kr">const</span> <span class="p">{</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">favoriteBank</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">getPerson</span><span class="p">();</span>
</pre></div>
</div>
<p>もし、必須項目の <code class="docutils literal notranslate"><span class="pre">favoriteBank</span></code> がなければ代入する場所でエラーが発生します。
また、リテラルで書く場合には、不要な項目があってもエラーになります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">person</span>: <span class="kt">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Yoichi&quot;</span>
<span class="p">};</span>
<span class="c1">// error TS2741: Property &#39;favoriteBank&#39; is missing in</span>
<span class="c1">//   type &#39;{ name: string; }&#39; but required in type &#39;Person&#39;.</span>
</pre></div>
</div>
<p>JavaScriptでは、多彩な機能を持つ関数を定義する場合に、オプションとなるパラメータをオブジェクトで渡す、という関数が数多くありました。
ちょっとタイプミスしてしまっただけで期待通りの結果を返さないでしばらく悩む、といったことがよくありました。
TypeScriptで型の定義をすると、このようなトラブルを未然に防ぐことができます。</p>
</div>
<div class="section" id="id5">
<h2>オブジェクトの属性の修飾: オプション、読み込み専用<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">readonly</span> <span class="nx">favoriteBank</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">favoriteGyudon?</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>名前の前に<code class="docutils literal notranslate"><span class="pre">readonly</span></code>を付与すると、属性の値が読み込み専用になり、書き込もうとするとエラーになります。
また、名前の後ろに <code class="docutils literal notranslate"><span class="pre">?</span></code> をつけることで、省略可能な属性であることを示すことができます。</p>
<p>これらにより、データの有無を柔軟にしたり、意図せぬ変更を抑制してバグを減らしたりする効果があります。</p>
<p>型ユーティリティを使えば、一度定義した型のすべての属性に一括して<code class="docutils literal notranslate"><span class="pre">?</span></code>をつけたり、<code class="docutils literal notranslate"><span class="pre">readonly</span></code>をつけることもできます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">favorite</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Partialをつけたので、全ての要素を設定しなくてもよい</span>
<span class="kr">const</span> <span class="nx">wzz</span>: <span class="kt">Partial</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;wzz&quot;</span><span class="p">};</span>

<span class="c1">// Readonlyになったので要素の書き換えが不可に</span>
<span class="kr">const</span> <span class="nx">bow</span>: <span class="kt">Readonly</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;bow&quot;</span><span class="p">,</span> <span class="nx">favorite</span><span class="o">:</span> <span class="s2">&quot;よなよなエール&quot;</span><span class="p">};</span>
<span class="nx">bow</span><span class="p">.</span><span class="nx">favorite</span> <span class="o">=</span> <span class="s2">&quot;水曜日の猫&quot;</span><span class="p">;</span>
<span class="c1">// Cannot assign to &#39;favorite&#39; because it is a read-only property.</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>属性名が可変のオブジェクトを扱う<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>これまで説明してきたのは、各キーの名前があらかじめ分かっている、他の言語で言うところの構造体のようなオブジェクトです。
しかし、このオブジェクトは辞書のようにも使われます。
今時であれば <code class="docutils literal notranslate"><span class="pre">Map</span></code> 型を使う方がイテレータなども使えますし、キーの型も自由に選べて良いのですが、例えば、サーバーAPIのレスポンスのJSONなどのようなところでは、どうしてもオブジェクトが登場します。</p>
<p>その時は、 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[key:</span> <span class="pre">キーの型]:</span> <span class="pre">値の型}</span></code> と書くことで、辞書のように扱われるオブジェクトの宣言ができます。
なお、 <code class="docutils literal notranslate"><span class="pre">key</span></code> の部分はなんでもよく、 <code class="docutils literal notranslate"><span class="pre">a</span></code> でも <code class="docutils literal notranslate"><span class="pre">b</span></code> でもエラーにはなりませんが、 <code class="docutils literal notranslate"><span class="pre">key</span></code> としておいた方がわかりやすいでしょう。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">postalCodes</span><span class="o">:</span> <span class="p">{</span> <span class="p">[</span><span class="nx">key</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">string</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">&quot;602-0000&quot;</span><span class="o">:</span> <span class="s2">&quot;京都市上京区&quot;</span><span class="p">,</span>
  <span class="s2">&quot;602-0827&quot;</span><span class="o">:</span> <span class="s2">&quot;京都市上京区相生町&quot;</span><span class="p">,</span>
  <span class="s2">&quot;602-0828&quot;</span><span class="o">:</span> <span class="s2">&quot;京都市上京区愛染寺町&quot;</span><span class="p">,</span>
  <span class="s2">&quot;602-0054&quot;</span><span class="o">:</span> <span class="s2">&quot;京都市上京区飛鳥井町&quot;</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>なお、キーの型には <code class="docutils literal notranslate"><span class="pre">string</span></code> 以外に <code class="docutils literal notranslate"><span class="pre">number</span></code> なども設定できます。その場合、上記の例だとエラーになりますが、 <code class="docutils literal notranslate"><span class="pre">&quot;6020000&quot;</span></code> （ダブルクオートがある点に注意）とするとエラーがなくなります。
一見数値が入っているように見えますが、JavaScriptのオブジェクトのキーは文字列型ですので、 <code class="docutils literal notranslate"><span class="pre">Object.keys()</span></code> とか <code class="docutils literal notranslate"><span class="pre">Object.entries()</span></code> で取り出すキーの型まで数字になるわけではなく、あくまでも文字列です。
数値としても認識できる文字列を受け取る、という挙動になります。</p>
</div>
<div class="section" id="ab">
<h2>AかつBでなければならない<a class="headerlink" href="#ab" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span></code> という記法（合併型）を紹介しました。これは「AもしくはB」という意味です。
コンピュータの論理式では「AかつB」というのがありますよね？
TypeScriptの型定義ではこれも表現できます。
<code class="docutils literal notranslate"><span class="pre">&amp;</span></code> の記号を使います。</p>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-text">型を合成する</span><a class="headerlink" href="#id16" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Twitter</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">twitterId</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">Instagram</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">instagramId</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">shibukawa</span>: <span class="kt">Twitter</span> <span class="o">&amp;</span> <span class="nx">Instagram</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">twitterId</span><span class="o">:</span> <span class="s2">&quot;@shibu_jp&quot;</span><span class="p">,</span>
  <span class="nx">instagramId</span><span class="o">:</span> <span class="s2">&quot;shibukawa&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>これは交差型（Intersection Type）と呼ばれ、両方のオブジェクトで定義した属性がすべて含まれないと、変数の代入のところでエラーになります。</p>
<p>もちろん、合成した型に名前をつけることもできます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">PartyPeople</span> <span class="o">=</span> <span class="nx">Twitter</span> <span class="o">&amp;</span> <span class="nx">Instagram</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>タグ付き合併型: パラメータの値によって必要な属性が変わる柔軟な型定義を行う<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>TypeScriptの型は、そのベースとなっているJavaScriptの動的な属性を包括的に扱えるように、かなり柔軟な定義もできるようになっています。
高速な表描画ライブラリのCheetahGrid<a class="footnote-reference brackets" href="#id9" id="id8">1</a>では、カラムの定義をJSONで行うことができます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">grid</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">cheetahGrid</span><span class="p">.</span><span class="nx">ListGrid</span><span class="p">({</span>
  <span class="nx">parentElement</span>: <span class="kt">document.querySelector</span><span class="p">(</span><span class="s1">&#39;#sample2&#39;</span><span class="p">),</span>
  <span class="nx">header</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span><span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="nx">caption</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span>
      <span class="nx">style</span><span class="o">:</span> <span class="p">{</span><span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;red&#39;</span><span class="p">}},</span>
    <span class="p">{</span><span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="nx">caption</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span>
      <span class="nx">style</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">uncheckBgColor</span><span class="o">:</span> <span class="s1">&#39;#FDD&#39;</span><span class="p">,</span>
        <span class="nx">checkBgColor</span><span class="o">:</span> <span class="s1">&#39;rgb(255, 73, 72)&#39;</span>
      <span class="p">}}</span>
  <span class="p">],</span>
<span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">columnType</span></code> の文字によって定義できる <code class="docutils literal notranslate"><span class="pre">style</span></code> の項目が変わります。今は、 <code class="docutils literal notranslate"><span class="pre">number</span></code> と、 <code class="docutils literal notranslate"><span class="pre">check</span></code> がありますね。
<code class="docutils literal notranslate"><span class="pre">check</span></code> の時は <code class="docutils literal notranslate"><span class="pre">uncheckBgColor</span></code> と <code class="docutils literal notranslate"><span class="pre">checkBgColor</span></code> が設定できますが、 <code class="docutils literal notranslate"><span class="pre">number</span></code> はそれらがなく、 <code class="docutils literal notranslate"><span class="pre">color</span></code> があります。
本物のCheetahGridはもっと多くの属性があるのですが、ここでは、このルールだけを設定可能なインタフェースを考えてみます。
簡略化のために属性の省略はないものとします（ただ?をつけるだけですが）。</p>
<p>TypeScriptのインタフェースの定義では「このキーがこの文字列の場合」という指定もできましたね。
次の定義は、チェックボックス用の設定になります。 <code class="docutils literal notranslate"><span class="pre">columnType:</span> <span class="pre">'check'</span></code> という項目があります。</p>
<div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-text">チェックボックスのカラム用の設定</span><a class="headerlink" href="#id17" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">CheckStyle</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">uncheckBgColor</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">checkBgColor</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">CheckColumn</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">;</span>
  <span class="nx">caption</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">field</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">style</span>: <span class="kt">CheckStyle</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>数値用のカラムも定義しましょう。</p>
<div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text">数値用のカラム用の設定</span><a class="headerlink" href="#id18" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">NumberStyle</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">color</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">NumberColumn</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">;</span>
  <span class="nx">caption</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">field</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">style</span>: <span class="kt">NumberStyle</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>上記のカラム定義の配列にはチェックボックスと数値のカラムの両方が来ます。どちらかだけの配列ではなくて、両方を含んでも良い配列を作ります。
その場合は、合併型を使って、その配列と定義すれば、両方を入れてもエラーにならない配列が定義できます。
ここでは <code class="docutils literal notranslate"><span class="pre">type</span></code> を使って、合併型に名前をつけています。それを配列にしています。</p>
<div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-text">チェックボックス、数値の両方を許容する汎用的な「カラム」型を定義</span><a class="headerlink" href="#id19" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 両方の型を取り得る合併型を定義</span>
<span class="nx">type</span> <span class="nx">Column</span> <span class="o">=</span> <span class="nx">CheckColumn</span> <span class="o">|</span> <span class="nx">NumberColumn</span><span class="p">;</span>

<span class="c1">// 無事、エラーを出さずに過不足なく型付けできた</span>
<span class="kr">const</span> <span class="nx">header</span>: <span class="kt">Column</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span>
 <span class="p">{</span><span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="nx">caption</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span>
   <span class="nx">style</span><span class="o">:</span> <span class="p">{</span><span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;red&#39;</span><span class="p">}},</span>
 <span class="p">{</span><span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="nx">caption</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span>
   <span class="nx">style</span><span class="o">:</span> <span class="p">{</span>
     <span class="nx">uncheckBgColor</span><span class="o">:</span> <span class="s1">&#39;#FDD&#39;</span><span class="p">,</span>
     <span class="nx">checkBgColor</span><span class="o">:</span> <span class="s1">&#39;rgb(255, 73, 72)&#39;</span>
   <span class="p">}}</span>
<span class="p">];</span>
</pre></div>
</div>
</div>
<p>このように、一部の属性の値によって型が決定され、どちらかの型かが選択されるような合併型を、タグ付き合併型（Tagged Union Type）と呼びます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>どこまで細かく型をつけるべきか？</p>
<p>これらの機能を駆使すると、かなり細かく型定義が行え、利用者が変な落とし穴に陥いるのを防ぐことができます。</p>
<p>しかし、最初に述べたように、時間は有限です。
型をつける作業は楽しい作業ではありますが、利用者数と見比べて、最初から全部を受け入れるような型を1つだけ作るところから始めても良いでしょう。
実際には次のような短い定義でも十分なことがほとんどです。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Style</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">color?</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">uncheckBgColor?</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">checkBgColor?</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">Column</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span> <span class="o">|</span> <span class="s1">&#39;check&#39;</span><span class="p">;</span>
  <span class="nx">caption</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">field</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">style</span>: <span class="kt">Style</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id8">1</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/future-architect/cheetah-grid">https://github.com/future-architect/cheetah-grid</a></p>
</dd>
</dl>
</div>
<div class="section" id="id10">
<h2>型ガード<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>静的な型付け言語では、どんどん型を厳しく付けていけばすべて幸せになりますよね！というわけにはいかない場面が少しだけあります。</p>
<p>TypeScriptでは、今まで見て来た通り、少し柔軟な型を許容しています。</p>
<ul class="simple">
<li><p>数値型か、あるいは <code class="docutils literal notranslate"><span class="pre">null</span></code></p></li>
<li><p>数字型か、文字列</p></li>
<li><p>オブジェクトの特定の属性 <code class="docutils literal notranslate"><span class="pre">columnType</span></code> が <code class="docutils literal notranslate"><span class="pre">'check'</span></code> という文字列の場合のみ属性が増える</p></li>
</ul>
<p>この複数の型を持つ変数を扱うときに、「2通りの選択肢があるうちの、こっちのパターンの場合のみのロジック」を記述したいときに使うのが型ガードです。</p>
<p>一般的な静的型付け言語でも、ダウンキャストなど、場合によってはプログラマーが意思を入れて型の変換を行わせることがありえます。場合によっては、うまく変換できなかったときに実行時エラーが発生しうる、実行文です。</p>
<p>例えば、Goの場合、HTTP/2の時は <code class="docutils literal notranslate"><span class="pre">http.ResponseWriter</span></code> は <code class="docutils literal notranslate"><span class="pre">http.Pusher</span></code> インタフェースを持っています。これにキャストすることで、サーバープッシュが実現できるというAPI設計になっています。実行時にはランタイムが型を見て変数に値を代入するなどしてくれます。</p>
<div class="literal-block-wrapper docutils container" id="id20">
<div class="code-block-caption"><span class="caption-text">Goのキャスト</span><a class="headerlink" href="#id20" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">pusher</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">http</span><span class="p">.</span><span class="nx">Pusher</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="c1">// ↑こちらでキャスト、成功するとbool型のok変数にtrueが入る</span>
        <span class="nx">pusher</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="s">&quot;/application.css&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
<p>しかし、TypeScriptのソースコードはあくまでも、JavaScriptに変換されてから実行されます。型情報などを消すだけでJavaScriptになります。TypeScriptのコンパイラが持つインタフェースや <code class="docutils literal notranslate"><span class="pre">type</span></code> などの固有の型情報は実行時にはランタイムには存在しません。そのため、「このオブジェクトがこのインタフェースを持っているとき」という実行文は他の言語のようにそのまま記述する方法はありません。</p>
<p>TypeScriptがこれを解決する手段として実装しているのが、型ガードという機能です。型情報を全部抜くと単なるJavaScriptとしても有効な文ですが、TypeScriptはこの実行文の文脈を解析し、型の選択肢を適切に絞り込んでいきます。これにより、正しいメソッドが利用されているかどうかを静的解析したりできますし、開発時においても、コード補完も正常に機能します。</p>
<div class="literal-block-wrapper docutils container" id="id21">
<div class="code-block-caption"><span class="caption-text">型ガード</span><a class="headerlink" href="#id21" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// userNameOrIdは文字列か数値</span>
<span class="kd">let</span> <span class="nx">userNameOrId</span>: <span class="kt">string</span><span class="o">|</span><span class="kt">number</span> <span class="o">=</span> <span class="nx">getUser</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">userNameOrId</span> <span class="o">===</span> <span class="s2">&quot;string&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// このif文の中では、userNameOrIdは文字列型として扱われる</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
        <span class="nx">userName</span>: <span class="kt">userNameOrId.toUpperCase</span><span class="p">()</span>
    <span class="p">});</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// このif文の中では、userNameOrIdは数値型として扱われる</span>
    <span class="kr">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">repository</span><span class="p">.</span><span class="nx">findUserByID</span><span class="p">(</span><span class="nx">userNameOrId</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
        <span class="nx">userName</span>: <span class="kt">user.getName</span><span class="p">()</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>組み込みの型ガード<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンパイラは、一部のTypeScriptの文を見て、型ガードと判定します。組み込みで使えるのは <code class="docutils literal notranslate"><span class="pre">typeof</span></code> や <code class="docutils literal notranslate"><span class="pre">instanceof</span></code> 、 <code class="docutils literal notranslate"><span class="pre">in</span></code> や比較です。</p>
<p><code class="docutils literal notranslate"><span class="pre">typeof</span> <span class="pre">変数</span></code> は変数の型名を文字列で返します。プリミティブな組込型のいくつかでしか対応できません。</p>
<ul class="simple">
<li><p>undefined: &quot;undefined&quot;</p></li>
<li><p>bool型: &quot;boolean&quot;</p></li>
<li><p>数値: &quot;number&quot;</p></li>
<li><p>文字列: &quot;string&quot;</p></li>
<li><p>シンボル: &quot;symbol&quot;</p></li>
<li><p>関数: &quot;function&quot;</p></li>
</ul>
<p>これ以外のほとんどは <code class="docutils literal notranslate"><span class="pre">object</span></code> になります。<code class="docutils literal notranslate"><span class="pre">null</span></code> も <code class="docutils literal notranslate"><span class="pre">object</span></code> になりますので、<code class="docutils literal notranslate"><span class="pre">typeof</span></code> は <code class="docutils literal notranslate"><span class="pre">null</span></code> の判定に使えません。</p>
<p><code class="docutils literal notranslate"><span class="pre">変数</span> <span class="pre">instanceof</span> <span class="pre">クラス名</span></code> は自作のクラスなどで使えるものになります。</p>
<p><code class="docutils literal notranslate"><span class="pre">&quot;キー&quot;</span> <span class="pre">in</span> <span class="pre">オブジェクト</span></code> で、オブジェクトに特定の属性が含まれているかどうかの判定ができます。</p>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> で型付けを行なったオブジェクトの複合型の場合、属性の有無や特定の属性の値がどうなっているかで判断できます。例えば、前述のカラム型の場合、field属性に文字列が入っていて型の判別ができました。これは、その属性値の比較のif文をかけばTypeScriptのコンパイラはきちんと解釈してくれます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Column</span> <span class="o">=</span> <span class="nx">CheckColumn</span> <span class="o">|</span> <span class="nx">NumberColumn</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">getValue</span><span class="p">(</span><span class="nx">column</span>: <span class="kt">Column</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">column</span><span class="p">.</span><span class="nx">field</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ここではcolumnはNumberColumn型</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// ここではcolumnはCheckColumn型</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>ユーザー定義の型ガード<a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>TypeScriptのベースになっているJavaScriptでは、長らくオブジェクトが配列かどうかを判定する明確な手法を提供してきませんでした。文字列にして、その結果をパースするとかも行われていました。ECMAScript 5の時代にようやく、 <code class="docutils literal notranslate"><span class="pre">Array.isArray()</span></code> というクラスメソッドが提供されるようになりました。</p>
<p>このようなメソッドは組み込みの型ガードとしては使えませんが、ユーザー定義の型ガード関数を作成すると、if文の中で特定の型とみなすようにTypeScriptコンパイラに教えることができます。</p>
<p>型ガード関数は、次のような形式で書きます。</p>
<div class="literal-block-wrapper docutils container" id="id22">
<div class="code-block-caption"><span class="caption-text">ユーザー定義の型ガード</span><a class="headerlink" href="#id22" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">arg</span>: <span class="kt">any</span><span class="p">)</span><span class="o">:</span> <span class="nx">arg</span> <span class="nx">is</span> <span class="nb">Array</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<ul class="simple">
<li><p>名前は <code class="docutils literal notranslate"><span class="pre">is型名</span></code> だとわかりやすい</p></li>
<li><p>引数は <code class="docutils literal notranslate"><span class="pre">arg:</span> <span class="pre">any</span></code></p></li>
<li><p>返り値の型は <code class="docutils literal notranslate"><span class="pre">arg</span> <span class="pre">is</span> <span class="pre">Array</span></code></p></li>
<li><p>関数の返り値は、型ガードの条件が満たされる実行文</p></li>
</ul>
<p>なんども説明している通り、型ガードではTypeScriptのコンパイラだけが知っている情報は扱えません。JavaScriptとして実行時にアクセスできる情報（ <code class="docutils literal notranslate"><span class="pre">Array.isArray()</span></code> のような関数、 <code class="docutils literal notranslate"><span class="pre">typeof</span></code> 、 <code class="docutils literal notranslate"><span class="pre">instanceof</span></code> 、 <code class="docutils literal notranslate"><span class="pre">in</span></code> 、比較などあらゆる方法を駆使）を使って、booleanを返す必要があります。</p>
</div>
<div class="section" id="id13">
<h3>型アサーション<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>TypeScriptではキャスト（型アサーション）もいちおうあります（ <code class="docutils literal notranslate"><span class="pre">as</span></code> を後置で置く）が、これは実行文ではなくて、あくまでもコンパイラの持つ型情報を上書きするものです。型ガードとは異なり、実行時には情報を一切参照せずに、ただ変数の型だけが変わります。もちろん、 <code class="docutils literal notranslate"><span class="pre">number</span></code> から <code class="docutils literal notranslate"><span class="pre">string</span></code> へのキャストなどの無理やりのキャストはエラーになりますが、 <code class="docutils literal notranslate"><span class="pre">any</span></code> 型への変換はいつでも可能ですし、 <code class="docutils literal notranslate"><span class="pre">any</span></code> から他の型への変換も自由にできます。一旦 <code class="docutils literal notranslate"><span class="pre">any</span></code> を挟むとコンパイラを騙してどんな型にも変換できてしまいますが、コンパイルエラーは抑制できても、実行時エラーになるだけなので、乱用しないようにしましょう。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">page</span>: <span class="kt">any</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;profile page&quot;</span> <span class="p">};</span>
<span class="c1">// any型からはasでどんな型にも変換できる</span>
<span class="kr">const</span> <span class="nx">name</span>: <span class="kt">string</span> <span class="o">=</span> <span class="nx">page</span> <span class="kr">as</span> <span class="kt">string</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="keyof-mapped-type">
<h2><code class="docutils literal notranslate"><span class="pre">keyof</span></code> とMapped Type: オブジェクトのキーの文字列のみを許容する動的な型宣言<a class="headerlink" href="#keyof-mapped-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この項目は中級者向けの項目になります。一般的にはジェネリクスと一緒に使うことが多い機能です。</p>
<p>JavaScriptは動的なオブジェクトを駆使してプログラミングをしてきました。そのオブジェクトが他の言語でいう構造体、あるいはレコード型のように特定の属性を持つことが分かっている用途でのみ使われるのであれば今まで説明してきた機能だけで十分に利用できます。</p>
<p>一方、 <code class="docutils literal notranslate"><span class="pre">Map</span></code> のように、何かしらの識別子をキーにして子供として要素を持つデータ構造として使われているケースなどもあります。例えばフォームのIDとその値をオブジェクトとして表現する場合は、フォームごとに項目が変わります。
そのような用途では、「このキーがある」「このキーのみを対象としたい」「このキーの型情報」みたいな型宣言がしたくなります。 <code class="docutils literal notranslate"><span class="pre">keyof</span></code> を使うとこのようなケースでの柔軟性があがります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Park</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">hasTako</span>: <span class="kt">boolean</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Parkのキーである、 &quot;name&quot; | &quot;hasTako&quot;が割り当てられる</span>
<span class="nx">type</span> <span class="nx">Key</span> <span class="o">=</span> <span class="nx">keyof</span> <span class="nx">Park</span><span class="p">;</span>
<span class="c1">// 指定されたキー以外はエラーになる</span>
<span class="kr">const</span> <span class="nx">key</span>: <span class="kt">Key</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span><span class="p">;</span>
<span class="c1">// 1行でも書ける</span>
<span class="kr">const</span> <span class="nx">key</span>: <span class="kt">keyof</span> <span class="nx">Park</span> <span class="o">=</span> <span class="s2">&quot;hasTako&quot;</span><span class="p">;</span>

<span class="c1">// 値の方の型も取れる(stringになる)</span>
<span class="nx">type</span> <span class="nx">ParkName</span> <span class="o">=</span> <span class="nx">Park</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">];</span>

<span class="c1">// 指定されたキー以外はエラーになる</span>
<span class="kr">const</span> <span class="nx">key</span>: <span class="kt">keyof</span> <span class="nx">Park</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>また、オブジェクトのキー全部に対して型定義をすることもできます。構造としては次のように書きます。
オブジェクトのキーは <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">]</span></code> でくくることで式を書くことができました。それの文法と似た書き方になっています。
Kというのがキー名の変数で、 <code class="docutils literal notranslate"><span class="pre">in</span></code> によるループの要素が1つずつ入るイメージです。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span>// 基本の書き方
{[K in keyof Object]: プロパティの型}

// 入力のObjectとキーは同じだがバリデーション結果を返す（値はすべてboolean）
{readonly [K in keyof Object]: boolean}

// 入力のObjectとまったく同じものをこの記法で書いたもの
{[K in keyof Object]: Object[K]}

// 入力のObjectとまったく同じだが読み込み専用
{readonly [K in keyof Object]: Object[K]}
</pre></div>
</div>
<p>なお、 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> を付与するのはジェネリクスなユーティリティ型 <code class="docutils literal notranslate"><span class="pre">Readonly&lt;T&gt;</span></code> というものがあるので実際にこのコードを書くことはないでしょう。</p>
<p>以下のコードが読み込み専用の型定義になります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">ParkForm</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">hasTako</span>: <span class="kt">boolean</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 値を全て読み込み専用にした型</span>
<span class="nx">type</span> <span class="nx">FrozenParkForm</span> <span class="o">=</span> <span class="p">{</span><span class="nx">readonly</span> <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">keyof</span> <span class="nx">ParkForm</span><span class="p">]</span><span class="o">:</span> <span class="nx">ParkForm</span><span class="p">[</span><span class="nx">K</span><span class="p">]};</span>

<span class="kr">const</span> <span class="nx">form</span>: <span class="kt">FrozenParkForm</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;恵比寿東&quot;</span><span class="p">,</span>
  <span class="nx">hasTako</span>: <span class="kt">true</span>
<span class="p">};</span>

<span class="c1">// 読み込み専用なのでエラーになる</span>
<span class="nx">form</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;和布刈公園&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>インタフェースを使った型定義<a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>オブジェクトの型をつける方法には、 <code class="docutils literal notranslate"><span class="pre">type</span></code> を使う方法以外に、インタフェース定義を使った方法もあります。
インタフェースは基本的には、Java同様に他の章で紹介するクラスのための機能ですが、
ほぼ同じことができますし、世間のコードではこちらの方もよく見かけます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">favoriteBank</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">favoriteGyudon?</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>前述の型を合成する方法についても、二つのインタフェースの継承でも表現できますが、あまり見かけたことはありません。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">PartyPeople</span> <span class="kr">extends</span> <span class="nx">Twitter</span><span class="p">,</span> <span class="nx">Instagram</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">shibukawa</span>: <span class="kt">PartyPeople</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">twitterId</span><span class="o">:</span> <span class="s2">&quot;@shibu_jp&quot;</span><span class="p">,</span>
  <span class="nx">instagramId</span><span class="o">:</span> <span class="s2">&quot;shibukawa&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="typescript">
<h2>もしTypeScriptの型を付けるのがコストが高いと感じたら？<a class="headerlink" href="#typescript" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>TypeScriptは既存のJavaScriptの使い方のすべてをカバーできるように機能を拡充しています。例えば、関数ではあるが属性を持つものや同じ関数が引数によって様々な型を返す可能性があるケースなど、他の静的型を最初からもって生まれた言語ではまずみないような物にも型付けができるようになっています。しかし、できることと、少ないコストでもできる、という2つには差があります。</p>
<p>通常であれば外部からの入出力や関数の入り口の宣言程度で済むはずで、実装コードの中の大部分は明示的に型を指定しなくても、推論で終了することが多いです。それでも済まないのは主に4つの理由が考えられます。</p>
<ol class="arabic simple">
<li><p>利用するライブラリがTypeScriptの型定義ファイルを用意していないケース。近年ではどんどん減っていますが、もし用意されていないのであれば型定義を自分で起こしたり、関数のレスポンスに自分で型定義を行う必要があるため、手間が増えます。</p></li>
<li><p>ライブラリの使用方法がTypeScriptフレンドリーではないケース。Redux-Toolkitではない通常のReduxでは、ステートやアクションの型定義を利用者側が細かく用意しなければなりません。Reactもクラスコンポーネントよりは関数コンポーネントの方が開発者が設定しなければならない型注釈は少なくて済みます。JavaScript時代に作られたライブラリによってはTypeScriptの型推論が効きにくいことがあります。</p></li>
<li><p>同一の変数に多様な型のものを入れようとしていたり、関数の引数や返り値も多様なものを返しているケース。<code class="docutils literal notranslate"><span class="pre">null</span></code>か何かしらのインスタンスか、ぐらいであれば、その関数の内部の実装や、利用者側のコードで型注釈が必要になることはごくまれです。特に返り値の型の種類が多様になる場合は要注意です。</p></li>
<li><p>多様な型を取り扱うためにジェネリクスなどの高度な型定義が必要になるケース。3のケースに付随してそれをカバーするためのコードが複雑になる場合です。</p></li>
</ol>
<p>TypeScriptでわざわざ型情報を付与するのは、コーディングでコード補完によるすばやいコーディングを実現したり、コードを入力中やコンパイルで問題をすばやく解決し、不具合の検出にかかる時間を節約するためだったり、工数の削減が目的です。もし、工数が余計にかかるというのは、高コストなのはコードの設計が「読むときのコンテキスト次第で状態が変わる」ような設計が原因のことがほとんどだと思うので、型付けがシンプルになるように設計を直していくべきという指標になりえます。</p>
<p>あと、TypeScriptのコンパイル（型チェック）は通るのに、実行時にエラーになるケースは、<code class="docutils literal notranslate"><span class="pre">as</span></code>などで手動で付けた型情報のミスが原因です。型チェックが信用できないので実行時に自分で<code class="docutils literal notranslate"><span class="pre">instanceof</span></code>などで型を見ざるをえないのであれば、それは上流の型定義を直していきましょう。TypeScriptのコンパイラがおかしい、信用できない、と思ったときは99%利用者側の責任でしょう。</p>
</div>
<div class="section" id="id15">
<h2>まとめ<a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本的な型付けの作法、とくにオブジェクトに対する型付けを学びました。
JavaScriptの世界では、プログラムのロジック以上に、柔軟なデータ構造を活用したコーディングが他の言語以上に行われていました。
そのため、ここで紹介した機能は、そのJavaScriptの世界に型を設定していくうえで必要性の高い知識となります。</p>
<p>これから紹介するクラスの場合は、実装時に自然と型定義もできあがりますが、TypeScriptではクラスに頼らない関数型スタイルのコーディングも増えています。
このオブジェクトの型付けは関数の入出力でも力を発揮するため、身につけておいて損はないでしょう。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="function.html" class="btn btn-neutral float-right" title="関数" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="syntax.html" class="btn btn-neutral float-left" title="基本的な構文" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 著作権 2019-2020, Future Corporation

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>