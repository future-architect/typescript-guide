<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>クラス &mdash; 仕事ですぐに使えるTypeScript  ドキュメント</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/translations.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="非同期処理" href="async.html" />
    <link rel="prev" title="その他の組み込み型・関数" href="otherbuiltinobjects.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> 仕事ですぐに使えるTypeScript
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">TypeScriptの世界を知る</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preface.html">前書き</a></li>
<li class="toctree-l1"><a class="reference internal" href="ecosystem.html">Node.jsエコシステムを体験しよう</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TypeScriptの書き方</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="variable.html">変数</a></li>
<li class="toctree-l1"><a class="reference internal" href="primitive.html">プリミティブ型</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">複合型</a></li>
<li class="toctree-l1"><a class="reference internal" href="syntax.html">基本的な構文</a></li>
<li class="toctree-l1"><a class="reference internal" href="typing.html">基本的な型付け</a></li>
<li class="toctree-l1"><a class="reference internal" href="function.html">関数</a></li>
<li class="toctree-l1"><a class="reference internal" href="otherbuiltinobjects.html">その他の組み込み型・関数</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">クラス</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#javascriptjava">JavaScriptとJava風オブジェクト指向文法の歴史</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">用語の整理</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">基本のクラス宣言</a></li>
<li class="toctree-l2"><a class="reference internal" href="#public-protected-private">アクセス制御（<code class="docutils literal notranslate"><span class="pre">public</span></code>/ <code class="docutils literal notranslate"><span class="pre">protected</span></code> / <code class="docutils literal notranslate"><span class="pre">private</span></code>）</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">コンストラクタの引数を使ってプロパティを宣言</a></li>
<li class="toctree-l2"><a class="reference internal" href="#static"><code class="docutils literal notranslate"><span class="pre">static</span></code> メンバー</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">インスタンスクラスフィールド</a></li>
<li class="toctree-l2"><a class="reference internal" href="#readonly">読み込み専用の変数（ <code class="docutils literal notranslate"><span class="pre">readonly</span></code> ）</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">メンバー定義方法のまとめ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">継承/インタフェース実装宣言</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">クラスとインタフェースの違い・使い分け</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">デコレータ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">まとめ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="async.html">非同期処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="exception.html">例外処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="module.html">モジュール</a></li>
<li class="toctree-l1"><a class="reference internal" href="console.html"><code class="docutils literal notranslate"><span class="pre">console.log</span></code>によるログ出力</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">中級のテクニック</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="generics.html">ジェネリクス</a></li>
<li class="toctree-l1"><a class="reference internal" href="functional.html">関数型指向のプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="class2.html">クラス上級編</a></li>
<li class="toctree-l1"><a class="reference internal" href="reactive.html">リアクティブ</a></li>
<li class="toctree-l1"><a class="reference internal" href="advance.html">高度なテクニック</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">環境ごとのTips（共通環境・ブラウザ以外）</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="prodenv.html">ソフトウェア開発の環境を考える</a></li>
<li class="toctree-l1"><a class="reference internal" href="baseenv.html">基本の環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="libenv.html">ライブラリ開発のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="clienv.html">CLIツール・ウェブサーバー作成のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">CI（継続的インテグレーション）環境の構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="deploy.html">成果物のデプロイ</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">使用ライブラリのバージョン管理</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">環境ごとのTips（ブラウザ環境）</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="browserenv.html">ブラウザ環境</a></li>
<li class="toctree-l1"><a class="reference internal" href="browserobjects.html">ブラウザ関連の組み込み型</a></li>
<li class="toctree-l1"><a class="reference internal" href="react.html">Reactの環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="vue.html">Vue.jsの環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="webparcel.html">Parcelを使ったウェブ開発</a></li>
<li class="toctree-l1"><a class="reference internal" href="electron.html">Electronアプリケーションの作成</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="recommended.html">おすすめのパッケージ・ツール</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html">貢献者</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">仕事ですぐに使えるTypeScript</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">クラス</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/class.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>クラス<a class="headerlink" href="#id1" title="この見出しへのパーマリンク"></a></h1>
<section id="javascriptjava">
<h2>JavaScriptとJava風オブジェクト指向文法の歴史<a class="headerlink" href="#javascriptjava" title="この見出しへのパーマリンク"></a></h2>
<p>クラスはプログラミング言語によってはとても重要な位置付けにあります。たとえば、Javaはすべての要素がクラスに属し、そのクラスの組み合わせでプログラムを作成していきます。クラスの利用方法を学び、クラスの実装方法を学び、よりよいクラスの設計方法を知ることがJavaにおいてはとても重要です。また、20年ほど前はJavaはプログラミングのパラダイムにおいては最先端であり、クラスを元にした設計手法、デザインパターン、アジャイルソフトウェア開発のプログラミング系のプラクティス（テスト駆動開発やリファクタリング）を通じて、多くのプログラミング言語にJava流の設計が輸出されていきました。クラスを使いこなすことで、次のことが実現可能になるとさかんに喧伝されていました。</p>
<ul class="simple">
<li><p>大規模なコード</p></li>
<li><p>再利用性の高いコード</p></li>
</ul>
<p>例えばPythonやRubyなどの今は古参扱いのプログラミング言語の多くも、当時は機能拡張を積極的に行っておりJavaやその周辺のベストプラクティスに影響を受けたと思われるライブラリなどがいくつか組み込まれています。クラスを持ってその先端の設計技法が利用できることは、当時の一級言語のステータスでした。</p>
<p>JavaScriptはクラスをダイレクトに表現する文法はなかったものの、昔は関数と<code class="docutils literal notranslate"><span class="pre">prototype</span></code>という属性をいじくり回してクラスを表現していました。正確には処理系的にはクラスではないのですが、コードのユーザー視点では他の言語のクラスと同等なのでここではこの当時の記法で作るものもクラスとして扱います。とはいえ、それでもJavaScriptはクラスがないことを理由に「大規模開発に向かないおもちゃ言語」と言われることもありました。</p>
<p>その欠点をカバーしてJavaなどのような書き味を求めて、ひと昔前のJavaScript界隈では、この<code class="docutils literal notranslate"><span class="pre">prototype</span></code>の仕組みをラップした自前の<code class="docutils literal notranslate"><span class="pre">extends</span></code>関数みたいなのを作ってクラスっぽいことを表現しようという一派も一時期いました。また、5年ほど前までは、クラスを使うためにCoffeeScriptに救いを求める人も多数いました。今のJavaScriptとTypeScriptでは、言語の標準機能として良い書き方が提供されています。</p>
<p>クラスをようやくサポートしたものの、近年ではクラスを使わない書き方、関数型言語のエッセンスを取り入れた書き方も流行ってきています。大規模といえばオブジェクト指向でクラス、という短絡的な言い方をする人はもはや絶滅危惧種です。</p>
<p>しかし、大規模なアプリケーションの部品としてではなく、末端の部品としては便利です。みなさんも、文字列や配列などの組み込み型を通じて、自然とオブジェクト指向には触れています。あのような部品を自分で作るための手段です。関数型のスタイルとも組み合わせて利用できますし、書き方を学んでおきましょう。</p>
</section>
<section id="id2">
<h2>用語の整理<a class="headerlink" href="#id2" title="この見出しへのパーマリンク"></a></h2>
<p>オブジェクト指向言語は、それぞれの言語ごとに使っている言葉が違うので、それを一旦整理します。本書では次の用語で呼びます。TypeScriptの公式ドキュメント準拠です。</p>
<ul>
<li><p>クラス（class）</p>
<p>他の言語のクラスと一緒です。ES2015以前のJavaScriptにはかつてなかったものです（似たようなものはありました）。</p>
</li>
<li><p>インスタンス（instance）</p>
<p>クラスを元にして <code class="docutils literal notranslate"><span class="pre">new</span></code> を呼び出して作ったオブジェクトです。</p>
</li>
<li><p>メソッド（method）</p>
<p>他の言語では、メンバー関数と呼んだり、フィールドと呼んでいたりします。名前を持ち、ロジックを書く場所です。自分が属しているインスタンスのプロパティやメソッドにアクセスできます。</p>
</li>
<li><p>プロパティ（property）</p>
<p>他の言語では、メンバー変数と呼んだり、フィールドと呼んでいたりします。名前を持ち、指定された型のデータを保持します。インスタンスごとに別の名前空間を持ちます。</p>
</li>
</ul>
</section>
<section id="id3">
<h2>基本のクラス宣言<a class="headerlink" href="#id3" title="この見出しへのパーマリンク"></a></h2>
<p>最初はコンストラクタ関数を作り、その <code class="docutils literal notranslate"><span class="pre">prototype</span></code> 属性を操作してクラスのようなものを作っていました。
今時の書き方は次のような<code class="docutils literal notranslate"><span class="pre">class</span></code>を使った書き方になり、他の言語を使っている人からも親しみやすくなりました。</p>
<p>なお、JavaScriptでは不要ですが、TypeScriptではプロパティの定義をクラス宣言の中で行う必要があります。定義していないプロパティアクセスはエラーになります。</p>
<div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-text">クラスの表現</span><a class="headerlink" href="#id19" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 新しいクラス表現</span><span class="w"></span>
<span class="kd">class</span><span class="w"> </span><span class="nx">SmallAnimal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// プロパティは名前: 型</span><span class="w"></span>
<span class="w">    </span><span class="nx">animaltype</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// コストラクタ（省略可能）</span><span class="w"></span>
<span class="w">    </span><span class="kr">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">animaltype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;ポメラニアン&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nx">say</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">animaltype</span><span class="si">}</span><span class="sb">だけどMSの中に永らく居たBOM信者の全身の毛をむしりたい`</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">smallAnimal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">SmallAnimal</span><span class="p">();</span><span class="w"></span>
<span class="nx">smallAnimal</span><span class="p">.</span><span class="nx">say</span><span class="p">();</span><span class="w"></span>
<span class="c1">// ポメラニアンだけどMSの中に永らく居たBOM信者の全身の毛をむしりたい</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>以前の書き方は次の通りです。</p>
<div class="literal-block-wrapper docutils container" id="id20">
<div class="code-block-caption"><span class="caption-text">旧来のクラスのようなものの表現</span><a class="headerlink" href="#id20" title="このコードへのパーマリンク"></a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="c1">// 古いクラスの表現</span><span class="w"></span>
<span class="c1">// 関数だけどコンストラクタ</span><span class="w"></span>
<span class="kd">function</span><span class="w"> </span><span class="nx">SmallAnimal</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">animaltype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;ポメラニアン&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// こうやって継承</span><span class="w"></span>
<span class="nx">SmallAnimal</span><span class="p">.</span><span class="nx">prototype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Parent</span><span class="p">();</span><span class="w"></span>

<span class="c1">// こうやってメソッド</span><span class="w"></span>
<span class="nx">SmallAnimal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">animalType</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot;だけどMSの中に永らく居たBOM信者の全身の毛をむしりたい&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
<section id="public-protected-private">
<h2>アクセス制御（<code class="docutils literal notranslate"><span class="pre">public</span></code>/ <code class="docutils literal notranslate"><span class="pre">protected</span></code> / <code class="docutils literal notranslate"><span class="pre">private</span></code>）<a class="headerlink" href="#public-protected-private" title="この見出しへのパーマリンク"></a></h2>
<p>TypeScriptにはC++やJavaのような <code class="docutils literal notranslate"><span class="pre">private</span></code> と <code class="docutils literal notranslate"><span class="pre">protected</span></code> 、 <code class="docutils literal notranslate"><span class="pre">public</span></code> 装飾子があります。
メンバー定義の時の <code class="docutils literal notranslate"><span class="pre">public</span></code> 装飾子は基本的につけてもつけなくても結果は変わりませんので、コメントのようなものです。
権限の考え方も同じで、 <code class="docutils literal notranslate"><span class="pre">private</span></code> は定義があるクラス以外からの操作を禁止、 <code class="docutils literal notranslate"><span class="pre">protected</span></code> は定義のあるクラスと子クラス以外からの操作を禁止、 <code class="docutils literal notranslate"><span class="pre">public</span></code> は内外問わず、すべての操作を許可、です。
オブジェクト指向言語だとRubyがやや特殊で、 <code class="docutils literal notranslate"><span class="pre">private</span></code> は「同一インスタンスからの操作のみを許可」ですが、これとは違う動作になります。</p>
<div class="literal-block-wrapper docutils container" id="id21">
<div class="code-block-caption"><span class="caption-text">アクセス制御</span><a class="headerlink" href="#id21" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 小型犬</span><span class="w"></span>
<span class="kd">class</span><span class="w"> </span><span class="nx">SmallDog</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 小型犬は宝物を秘密の場所に埋める</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="nx">secretPlace</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="nx">dig</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">secretPlace</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 埋める</span><span class="w"></span>
<span class="w">  </span><span class="nx">bury</span><span class="p">(</span><span class="nx">treasure</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">secretPlace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">treasure</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">miniatureDachshund</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">SmallDog</span><span class="p">();</span><span class="w"></span>
<span class="c1">// 埋めた</span><span class="w"></span>
<span class="nx">miniatureDachshund</span><span class="p">.</span><span class="nx">bury</span><span class="p">(</span><span class="s2">&quot;骨&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// 秘密の場所を知っているのは小型犬のみ</span><span class="w"></span>
<span class="c1">// アクセスするとエラー</span><span class="w"></span>
<span class="c1">// error TS2341: Property &#39;secretPlace&#39; is private and</span><span class="w"></span>
<span class="c1">// only accessible within class &#39;SmallDog&#39;.</span><span class="w"></span>
<span class="nx">miniatureDachshund</span><span class="p">.</span><span class="nx">secretPlace</span><span class="p">;</span><span class="w"></span>

<span class="c1">// 掘り出した</span><span class="w"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">miniatureDachshund</span><span class="p">.</span><span class="nx">dig</span><span class="p">());</span><span class="w"> </span><span class="c1">// 骨</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>古くはJavaScriptではさまざまなトリックを使って <code class="docutils literal notranslate"><span class="pre">private</span></code> 宣言を再現しようといろいろなテクニックが作られました。
もはや使わない、と前章で紹介した即時実行関数も、すべて <code class="docutils literal notranslate"><span class="pre">private</span></code> のようなものを実現するためのものでした。
それ以外だと、簡易的に <code class="docutils literal notranslate"><span class="pre">_</span></code> をメンバー名の前につけて「仕組み上はアクセスできるけど、使わないでね」とコーディング規約でカバーする方法もありました。</p>
<p>また <code class="docutils literal notranslate"><span class="pre">protected</span></code> は継承して使うことを前提としたスコープですが、JavaはともかくTypeScriptでは階層が深くなる継承をすることはまずないので、使うことはないでしょう。</p>
</section>
<section id="id4">
<h2>コンストラクタの引数を使ってプロパティを宣言<a class="headerlink" href="#id4" title="この見出しへのパーマリンク"></a></h2>
<p>TypeScript固有の書き方になりますが、コンストラクタ関数にアクセス制御の装飾子をつけると、それがそのままプロパティになります。
コンストラクタの引数をそのまま同名のプロパティに代入します。</p>
<div class="literal-block-wrapper docutils container" id="id22">
<div class="code-block-caption"><span class="caption-text">プロパティ定義をコンストラクタ変数に</span><a class="headerlink" href="#id22" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 小型犬</span><span class="w"></span>
<span class="kd">class</span><span class="w"> </span><span class="nx">SmallDog</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">(</span><span class="k">private</span><span class="w"> </span><span class="nx">secretPlace</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nx">dig</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">secretPlace</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 埋める</span><span class="w"></span>
<span class="w">  </span><span class="nx">bury</span><span class="p">(</span><span class="nx">treasure</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">secretPlace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">treasure</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>これはコンストラクターの引数になったので、初期化時に渡してあげると初期化が完了します。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">miniatureDachshund</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">SmallDog</span><span class="p">(</span><span class="s2">&quot;フリスビー&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// 掘り出した</span><span class="w"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">miniatureDachshund</span><span class="p">.</span><span class="nx">dig</span><span class="p">());</span><span class="w"> </span><span class="c1">// フリスビー</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="static">
<h2><code class="docutils literal notranslate"><span class="pre">static</span></code> メンバー<a class="headerlink" href="#static" title="この見出しへのパーマリンク"></a></h2>
<p>オブジェクトの要素はみな、基本的に <code class="docutils literal notranslate"><span class="pre">new</span></code> をして作られるインスタンスごとにデータを保持します。メソッドも <code class="docutils literal notranslate"><span class="pre">this</span></code> は現在実行中のインスタンスを指します。
<code class="docutils literal notranslate"><span class="pre">static</span></code> をつけたプロパティは、インスタンスではなくてクラスという1つだけの要素に保存されます。 <code class="docutils literal notranslate"><span class="pre">static</span></code> メソッドも、インスタンスではなくてクラス側に属します。</p>
<div class="literal-block-wrapper docutils container" id="id23">
<div class="code-block-caption"><span class="caption-text">プロパティ定義をコンストラクタ変数に</span><a class="headerlink" href="#id23" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nx">StaticSample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 静的なプロパティ</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="nx">staticVariable</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 通常のプロパティ</span><span class="w"></span>
<span class="w">  </span><span class="nx">variable</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 静的なメソッド</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="nx">classMethod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 静的なメソッドから静的プロパティは ``this.`` もしくは、 ``クラス名.`` で参照可能</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">staticVariable</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">StaticSample</span><span class="p">.</span><span class="nx">staticVariable</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 通常のプロパティは参照不可</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">variable</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// error TS2339: Property &#39;variable&#39; does not exist on</span><span class="w"></span>
<span class="w">    </span><span class="c1">//     type &#39;typeof StaticSample&#39;.</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nx">method</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 通常のメソッドから通常のプロパティは ``this.`` で参照可能</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">variable</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 通常のメソッドから静的なプロパティは ``クラス名.`` で参照可能</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">StaticSample</span><span class="p">.</span><span class="nx">staticVariable</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 通常のメソッドから静的なプロパティを ``this.`` では参照不可</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">staticVariable</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// error TS2576: Property &#39;staticVariable&#39; is a static</span><span class="w"></span>
<span class="w">    </span><span class="c1">//     member of type &#39;StaticSample&#39;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>Javaと違って、すべての要素をクラスで包む必要はないため、 <code class="docutils literal notranslate"><span class="pre">static</span></code> メンバーを使わずにふつうの関数や変数を使って実装することもできます。
静的メソッドが便利そうな唯一のケースとしては、インスタンスを作る特別なファクトリーメソッドを実装するぐらいでしょうか。
次のクラスは図形の点を表現するクラスですが、 <code class="docutils literal notranslate"><span class="pre">polar()</span></code> メソッドは極座標を使って作成するファクトリーメソッドになっています。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nx">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 通常のコンストラクタ</span><span class="w"></span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">(</span><span class="k">public</span><span class="w"> </span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="nx">y</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 極座標のファクトリーメソッド</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="nx">polar</span><span class="p">(</span><span class="nx">length</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="nx">angle</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Point</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="nx">length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">angle</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="nx">length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">angle</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="ow">new</span><span class="w"> </span><span class="nx">Point</span><span class="p">(</span><span class="mf">10</span><span class="p">,</span><span class="w"> </span><span class="mf">20</span><span class="p">));</span><span class="w"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">polar</span><span class="p">(</span><span class="mf">10</span><span class="p">,</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.25</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>静的なプロパティを使いすぎると、複製できないクラスになってしまい、テストなどがしにくくなります。
あまり多用することはないでしょう。</p>
</section>
<section id="id5">
<h2>インスタンスクラスフィールド<a class="headerlink" href="#id5" title="この見出しへのパーマリンク"></a></h2>
<p>JavaScriptではまだStage 3の機能ですが、TypeScriptですでに使える文法として導入されているがインスタンスクラスフィールド<a class="footnote-reference brackets" href="#id9" id="id6">1</a> <a class="footnote-reference brackets" href="#id10" id="id7">2</a> という文法です。
この提案にはいくつかの文法が含まれていますが、publicメンバーのみをここで紹介します。</p>
<p>イベントハンドラにメソッドを渡す時は、メソッド単体を渡すと、オブジェクト引き剥がされてしまって<code class="docutils literal notranslate"><span class="pre">this</span></code> が行方不明になってしまうため、これまでは <code class="docutils literal notranslate"><span class="pre">bind()</span></code> を使って回避していたことはすでに紹介しました。
インスタンスクラスフィールドを使うと、クラス宣言の中にプロパティ宣言を書くことができ、オブジェクトがインスタンス化されるときに設定されます。
このときにアロー関数が利用できるため、イベントハンドラにメソッドをそのまま渡しても問題なく動作するようになります。</p>
<p>アロー関数を単体で使っても便利ですが、Reactの <code class="docutils literal notranslate"><span class="pre">render()</span></code> の中で使うと、表示のたびに別の関数オブジェクトが作られたと判断されて、表示のキャッシュがうまく行われずにパフォーマンスが悪化する欠点があります<a class="footnote-reference brackets" href="#id11" id="id8">3</a> 。
インスタンスクラスフィールドとして定義すると、コンストラクタの中で一回だけ設定されるだけなので、この問題を避けることができます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 新: インスタンスクラスフィールドを使う場合</span><span class="w"></span>
<span class="kd">class</span><span class="w"> </span><span class="nx">SmallAnimal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// プロパティを作成</span><span class="w"></span>
<span class="w">  </span><span class="nx">fav</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;小田原&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// メソッドを作成</span><span class="w"></span>
<span class="w">  </span><span class="nx">say</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`私は</span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">fav</span><span class="si">}</span><span class="sb">が好きです`</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>以前は <code class="docutils literal notranslate"><span class="pre">bind()</span></code> を使ってコンストラクタの中で設定していました。
インスタンスクラスフィールドもコンストラクタ実行のときに実行されるので、実行結果は変わりません。</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="c1">// 旧: bindを使う場合</span><span class="w"></span>
<span class="kd">class</span><span class="w"> </span><span class="nx">SmallAnimal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">_fav</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;小春日&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">say</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">say</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nx">say</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`私は</span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">_fav</span><span class="si">}</span><span class="sb">が好きです`</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ECMAScript側のインスタンスクラスフィールドの仕様では <code class="docutils literal notranslate"><span class="pre">private</span></code> の定義は <code class="docutils literal notranslate"><span class="pre">private</span></code> キーワードではなくて <code class="docutils literal notranslate"><span class="pre">#</span></code> を名前の前につける記法が提案されています。</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id6">1</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/tc39/proposal-class-fields">https://github.com/tc39/proposal-class-fields</a></p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id7">2</a></span></dt>
<dd><p>Babelでは&#64;babel/plugin-proposal-class-propertiesプラグインを導入すると使えます</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id8">3</a></span></dt>
<dd><p><a class="reference external" href="https://medium.freecodecamp.org/why-arrow-functions-and-bind-in-reacts-render-are-problematic-f1c08b060e36">https://medium.freecodecamp.org/why-arrow-functions-and-bind-in-reacts-render-are-problematic-f1c08b060e36</a></p>
</dd>
</dl>
</section>
<section id="readonly">
<h2>読み込み専用の変数（ <code class="docutils literal notranslate"><span class="pre">readonly</span></code> ）<a class="headerlink" href="#readonly" title="この見出しへのパーマリンク"></a></h2>
<p>変数には <code class="docutils literal notranslate"><span class="pre">const</span></code> がありましたが、プロパティにも <code class="docutils literal notranslate"><span class="pre">readonly</span></code> があります。
<code class="docutils literal notranslate"><span class="pre">readonly</span></code> を付与したプロパティは、プロパティ定義時および、コンストラクタの中身でのみ書き換えることができます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nx">SimLockPhone</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">readonly</span><span class="w"> </span><span class="nx">carrier</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">(</span><span class="nx">carrier</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">carrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">carrier</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// キャリア変更できない！</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">myPhone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">SimLockPhone</span><span class="p">(</span><span class="s2">&quot;Docomo&quot;</span><span class="p">);</span><span class="w"></span>
<span class="nx">myPhone</span><span class="p">.</span><span class="nx">carrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;au&quot;</span><span class="p">;</span><span class="w"></span>
<span class="c1">// error TS2540: Cannot assign to &#39;carrier&#39; because it is a read-only property.</span><span class="w"></span>
</pre></div>
</div>
<p>なお、通常のプロパティ定義以外にも、コンストラクタを使ったプロパティ定義、インスタンスクラスフィールドの定義で使うことができます。
また、アクセス制御と一緒に使う場合は、 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> をあとにしてください。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nx">BankAccount</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">(</span><span class="k">private</span><span class="w"> </span><span class="k">readonly</span><span class="w"> </span><span class="nx">accountNumber</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id12">
<h2>メンバー定義方法のまとめ<a class="headerlink" href="#id12" title="この見出しへのパーマリンク"></a></h2>
<p>外からプロパティ、メソッドに見えるものの定義の種類がたくさんありました。
それぞれ、メリットがありますので、用途に応じて使い分けると良いでしょう。
また既存のコードを読むときに、メンバーの定義のコードを確認する場合はこれのどの方法で定義されているのかを確認する必要があります。</p>
<p>これ以外にも、アクセッサがあります。これについては <a class="reference internal" href="class2.html"><span class="doc">クラス上級編</span></a> で紹介します。</p>
<table class="colwidths-given docutils align-default" id="id24">
<caption><span class="caption-text">メンバーの定義方法</span><a class="headerlink" href="#id24" title="このテーブルへのパーマリンク"></a></caption>
<colgroup>
<col style="width: 34%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>サンプル</p></th>
<th class="head"><p>メソッド</p></th>
<th class="head"><p>変数</p></th>
<th class="head"><p>JS互換</p></th>
<th class="head"><p>メリット</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// プロパティ</span><span class="w"></span>
<span class="nx">secretPlace</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>

<span class="c1">// メンバーメソッド</span><span class="w"></span>
<span class="nx">dig</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">secretPlace</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
<td><p>○</p></td>
<td><p>○</p></td>
<td><p>○</p></td>
<td><p>一番シンプルで、継承やインタフェース機能との相性が良い。</p></td>
</tr>
<tr class="row-odd"><td><div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// コンストラクタ引数</span><span class="w"></span>
<span class="kr">constructor</span><span class="p">(</span><span class="k">private</span><span class="w"> </span><span class="nx">secretPlace</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</td>
<td></td>
<td><p>○</p></td>
<td></td>
<td><p>コンストラクタで外から定義する口とメンバーの宣言が1箇所で済む。初期値の設定が可能</p></td>
</tr>
<tr class="row-even"><td><div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// インスタンスクラスフィールド</span><span class="w"></span>
<span class="k">private</span><span class="w"> </span><span class="nx">secretPlace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;フリスビー&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</td>
<td></td>
<td><p>○</p></td>
<td><p>△</p></td>
<td><p>初期値の設定が可能で、右辺から型が明確にわかる場合は型宣言を省略できる。アロー関数を代入することで <code class="docutils literal notranslate"><span class="pre">bind()</span></code> を使わずに、イベントハンドラに安全に渡せるメソッドが定義できる。</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id13">
<h2>継承/インタフェース実装宣言<a class="headerlink" href="#id13" title="この見出しへのパーマリンク"></a></h2>
<p>作られたクラスを元に機能拡張する方法がいくつかあります。そのうちの1つが継承です。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nx">SmallAnimal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">eat</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;中本を食べに行きました&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">class</span><span class="w"> </span><span class="nx">Pomeranian</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nx">SmallAnimal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">eat</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;シュークリームを食べに行きました&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>もう1つ、インタフェースについては前章で説明しました。前章ではオブジェクトの要素の型定義として紹介しましたが、クラスとも連携します。
むしろJavaで導入された経緯を考えると、こちらの用途の方が出自が先でしょう。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">interface</span><span class="w"> </span><span class="nx">Animal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">eat</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">class</span><span class="w"> </span><span class="nx">SmallAnimal</span><span class="w"> </span><span class="k">implements</span><span class="w"> </span><span class="nx">Animal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">eat</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;中本を食べに行きました&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>インタフェースは、クラスが実装すべきメソッドやプロパティを定義することができ、足りないメソッドなどがあるとエラーが出力されます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// インタフェースで定義されたメソッドを実装しなかった</span><span class="w"></span>
<span class="kd">class</span><span class="w"> </span><span class="nx">SmallAnimal</span><span class="w"> </span><span class="k">implements</span><span class="w"> </span><span class="nx">Animal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// error TS2420: Class &#39;SmallAnimal&#39; incorrectly implements interface &#39;Animal&#39;.</span><span class="w"></span>
<span class="w">     </span><span class="nx">Property</span><span class="w"> </span><span class="s1">&#39;eat&#39;</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">missing</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="s1">&#39;SmallAnimal&#39;</span><span class="w"> </span><span class="nx">but</span><span class="w"> </span><span class="nx">required</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="s1">&#39;Animal&#39;</span><span class="p">.</span><span class="w"></span>
</pre></div>
</div>
<p>今、この <code class="docutils literal notranslate"><span class="pre">eat()</span></code> メソッドには返り値が定義されていません。もしコンパイルオプションが <code class="docutils literal notranslate"><span class="pre">compilerOptions.noImplicitAny</span></code> の場合、ここでエラーが発生します。</p>
<div class="literal-block-wrapper docutils container" id="id25">
<div class="code-block-caption"><span class="caption-text">インタフェースの返り値の型を省略すると・・・</span><a class="headerlink" href="#id25" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">interface</span><span class="w"> </span><span class="nx">Animal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">eat</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// error TS7010: &#39;eat&#39;, which lacks return-type annotation,</span><span class="w"></span>
<span class="c1">//   implicitly has an &#39;any&#39; return type.</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>明示的に <code class="docutils literal notranslate"><span class="pre">void</span></code> をつけたり、型情報をつけるとエラーは解消されます。</p>
<div class="literal-block-wrapper docutils container" id="id26">
<div class="code-block-caption"><span class="caption-text">返り値を返さない関数にはvoidをつける</span><a class="headerlink" href="#id26" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">interface</span><span class="w"> </span><span class="nx">Animal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">eat</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>関数のところの型定義で紹介したように、TypeScriptは実際のコードの情報を元に、ソースコードを解析して返り値の型を推測します。
しかし、このインタフェースには実装がないため、推測ができず、常に <code class="docutils literal notranslate"><span class="pre">any</span></code> （なにかを返す）という型になってしまいます。
これは型チェックを厳密に行っていくには穴が空きすぎてしまいエディタの補助が聞かなくなって開発効率向上が得にくくなります。
<code class="docutils literal notranslate"><span class="pre">noImplicitAny</span></code> というオプションを使うとこの穴を塞げます。
そのため、「何も返さない」という型も含め、手動で型をつける必要があります。</p>
</section>
<section id="id14">
<h2>クラスとインタフェースの違い・使い分け<a class="headerlink" href="#id14" title="この見出しへのパーマリンク"></a></h2>
<p>クラスとインタフェースは宣言は似ています。</p>
<p>違いがある点は以下の通りです。</p>
<ul class="simple">
<li><p>クラスをもとに <code class="docutils literal notranslate"><span class="pre">new</span></code> を使ってインスタンスを作ることはできるが、インタフェースはできない</p></li>
<li><p>インタフェースはインスタンスが作れないので、コンストラクタを定義できない</p></li>
<li><p>インタフェースは <code class="docutils literal notranslate"><span class="pre">public</span></code> メンバーしか定義できないが、クラスは他のアクセス制御も可能</p></li>
</ul>
<p>継承とかオブジェクト指向設計とか方法論とかメソッドはメッセージで云々とか語り出すと大抵炎上するのがオブジェクト指向とかクラスの説明の難しいところです。
これらの機能は、言語の文化とか、他の代替文法の有無とかで使われ方が大きく変わってきます。</p>
<p>TypeScript界隈では、Angularなどのフレームワークではインタフェースが多用されています。
ユーザーが実装するコンポーネントなどのクラスにおいて、Angularが提供するサービスを受けるためのメソッドの形式が決まっていて、実装部分の中身をライブラリユーザーが実装するといった使われ方をしています。
<code class="docutils literal notranslate"><span class="pre">OnInit</span></code> をimplementsすると、初期化時に呼び出されるといった具合です。</p>
<p>継承が必要となるのは実装も提供する必要がある場合ですが、コードが追いかけにくくなるとか、拡張性のあるクラス設計が難しいとかもあり、引き継ぐべきメソッドが大量にあるクラス以外で積極的に使うケースはあまり多くないかもしれません。</p>
<p>しかし、TypeScriptはJavaScriptエコシステムと密接に関わっており、JavaScriptの世界にはインタフェースを提供することはできず、実装の保証をする機能が確実に動くとは限りません。
TypeScriptのように、フレームワーク側もTypeScriptで、実装コードもTypeScriptというケースでなければ利用しにくいことが多々あります。
特に、ライブラリ側がJavaScriptで実装されている場合はクラスを使って継承、という使い方になります。</p>
</section>
<section id="id15">
<h2>デコレータ<a class="headerlink" href="#id15" title="この見出しへのパーマリンク"></a></h2>
<p>これもStage 2の機能<a class="footnote-reference brackets" href="#id17" id="id16">4</a>ですが、これもすでに多くのライブラリやフレームワークで利用されています。
TypeScriptではtsconfig.jsonの<code class="docutils literal notranslate"><span class="pre">compilerOptions.experimentalDecorators</span></code>に<code class="docutils literal notranslate"><span class="pre">true</span></code>設定すると使えます。
使い方から内部の動きまでPython 2.5で導入されたデコレータと似ています。
決まった引数とレスポンスを持つ関数を作り、<code class="docutils literal notranslate"><span class="pre">&#64;</span></code> の記号をつけて、クラスなどの前に付与すると、宣言が完了したオブジェクトなどが引数に入ってこの関数が呼ばれます。
他の言語でアトリビュートと呼ばれる機能と似ていますが、動的言語なので型情報の追加情報として設定されるのではなく、関数を通じてそれが付与されている対象のクラスやメソッド、属性を受け取り、それを加工する、変更する、記録するといった動作をします。
たとえば、ウェブアプリケーションでURLとメソッドのマッピングをデコレータで宣言したり、関数実行時にログを出すようにする、権限チェックやバリデーションを追加する、メソッドを追加するなど、用途はかなり広いです。
また、複数のデコレータを設定したりもできます。</p>
<p>次のコードは引数のないクラスデコレータの例です。
クラスに付与するもの、属性に付与するもの、それぞれ引数を持つものと持たないものがあるので、書き方が4通りありますが、詳細は割愛します。</p>
<div class="literal-block-wrapper docutils container" id="id27">
<div class="code-block-caption"><span class="caption-text">デコレータでクラスにメソッドを追加する</span><a class="headerlink" href="#id27" title="このコードへのパーマリンク"></a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span>function StrongZero(target) {
  target.prototype.drink = function() {
    console.log(&quot;ストロングゼロを飲んだ&quot;);
  };
  return target;
}

@StrongZero
class SmallAnimal {
}

const sa = new SmallAnimal();
sa.drink();
</pre></div>
</div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id16">4</a></span></dt>
<dd><p>Babelでは&#64;babel/plugin-proposal-decoratorsプラグインが必要です。</p>
</dd>
</dl>
</section>
<section id="id18">
<h2>まとめ<a class="headerlink" href="#id18" title="この見出しへのパーマリンク"></a></h2>
<p>クラスにまつわる数々の機能を取り上げて来ました。
昔のJavaScriptをやっていたプログラマーから見ると、一番変化と進歩を感じるところがこのクラスでしょう。
一般的なクラスの機能を備えた上で、型チェックも行われ、さらにデコレータなど追加機能なども含まれました。
TypeScriptの場合は、エディタによるコード補完の正答率が大幅に上がったりしてリターンが大きいため、生産性の高まりを感じられるでしょう。</p>
<p>いろいろと機能は多いですが、TypeScriptでは、あまりクラスの細かい機能を多用するコーディングは行われていません。
そのため、本章で取り上げた機能のうち、使わない機能も多いはずです。
ちょっとしたロジックが書ける（バリデーションなど）構造体、といった感じで使われることがほとんどでしょう。
最重要なところをピックアップするとしたら次のあたりです。</p>
<ul class="simple">
<li><p>基本のクラス宣言</p></li>
<li><p>アクセス制御（ <code class="docutils literal notranslate"><span class="pre">public</span></code>/ <code class="docutils literal notranslate"><span class="pre">private</span></code> ）</p></li>
<li><p>インスタンスクラスフィールド</p></li>
<li><p>インタフェース実装宣言</p></li>
</ul>
<p>次のものは覚えておいても損はないでしょう。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">static</span></code> メンバー</p></li>
<li><p>コンストラクタの引数を使ってプロパティを宣言</p></li>
<li><p>読み込み専用の変数（ <code class="docutils literal notranslate"><span class="pre">readonly</span></code> ）</p></li>
</ul>
<p>次の機能はライブラリを提供する側が覚えておくとおしゃれな機能です。</p>
<ul class="simple">
<li><p>デコレータ</p></li>
</ul>
<p>次の機能をTypeScriptで駆使するようになったら警戒しましょう。
まず、2段、3段、4段と続くような深い継承になるようなコードを書くことはないでしょう。
<code class="docutils literal notranslate"><span class="pre">private</span></code> はともかく継承を前提とする <code class="docutils literal notranslate"><span class="pre">protected</span></code> 、抽象クラスを多用するような複雑なクラス設計がでてきたら、アプリケーションコードレベルではほぼ間違いだと思います。
もしかしたら、DOMに匹敵するような大規模なクラスライブラリを作るのであれば、抽象クラスだとか <code class="docutils literal notranslate"><span class="pre">protected</span></code> も活躍するかもしれませんが、ほぼ稀でしょう。
せいぜいインタフェースを定義して、特定のメソッドを持っていたら仲間とみなす、ぐらいのダックタイピングとクラス指向の中間ぐらいがTypeScriptのスイートスポットだと思います。</p>
<ul class="simple">
<li><p>アクセス制御（ <code class="docutils literal notranslate"><span class="pre">protected</span></code> ）</p></li>
<li><p>継承</p></li>
</ul>
<p>アプリケーション開発者は使わないが、ライブラリ・フレームワーク実装者は使うかもしれない機能は、上級編として、 <a class="reference internal" href="class2.html"><span class="doc">クラス上級編</span></a> の章で紹介します。
次の要素について紹介します。</p>
<ul class="simple">
<li><p>アクセッサ</p></li>
<li><p>抽象クラス</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="otherbuiltinobjects.html" class="btn btn-neutral float-left" title="その他の組み込み型・関数" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="async.html" class="btn btn-neutral float-right" title="非同期処理" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020, Future Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>