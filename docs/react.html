

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Reactの環境構築 &mdash; 仕事ですぐに使えるTypeScript  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="Vue.jsの環境構築" href="vue.html" />
    <link rel="prev" title="ブラウザ関連の組み込み型" href="browserobjects.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> 仕事ですぐに使えるTypeScript
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">TypeScriptの世界を知る</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preface.html">前書き</a></li>
<li class="toctree-l1"><a class="reference internal" href="ecosystem.html">Node.jsエコシステムを体験しよう</a></li>
</ul>
<p class="caption"><span class="caption-text">TypeScriptの書き方</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="variable.html">変数</a></li>
<li class="toctree-l1"><a class="reference internal" href="primitive.html">プリミティブ型</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">複合型</a></li>
<li class="toctree-l1"><a class="reference internal" href="syntax.html">基本的な構文</a></li>
<li class="toctree-l1"><a class="reference internal" href="typing.html">基本的な型付け</a></li>
<li class="toctree-l1"><a class="reference internal" href="function.html">関数</a></li>
<li class="toctree-l1"><a class="reference internal" href="otherbuiltinobjects.html">その他の組み込み型・関数</a></li>
<li class="toctree-l1"><a class="reference internal" href="class.html">クラス</a></li>
<li class="toctree-l1"><a class="reference internal" href="async.html">非同期処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="exception.html">例外処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="module.html">モジュール</a></li>
<li class="toctree-l1"><a class="reference internal" href="console.html"><code class="docutils literal notranslate"><span class="pre">console.log</span></code>によるログ出力</a></li>
</ul>
<p class="caption"><span class="caption-text">中級のテクニック</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="generics.html">ジェネリクス</a></li>
<li class="toctree-l1"><a class="reference internal" href="functional.html">関数型指向のプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="class2.html">クラス上級編</a></li>
<li class="toctree-l1"><a class="reference internal" href="reactive.html">リアクティブ</a></li>
<li class="toctree-l1"><a class="reference internal" href="advance.html">高度なテクニック</a></li>
</ul>
<p class="caption"><span class="caption-text">環境ごとのTips（共通環境・ブラウザ以外）</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="prodenv.html">ソフトウェア開発の環境を考える</a></li>
<li class="toctree-l1"><a class="reference internal" href="baseenv.html">基本の環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="libenv.html">ライブラリ開発のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="clienv.html">CLIツール・ウェブサーバー作成のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">CI（継続的インテグレーション）環境の構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="deploy.html">成果物のデプロイ</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">使用ライブラリのバージョン管理</a></li>
</ul>
<p class="caption"><span class="caption-text">環境ごとのTips（ブラウザ環境）</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="browserobjects.html">ブラウザ関連の組み込み型</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reactの環境構築</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">ウェブアプリケーションにおけるビルドツールのゴール</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">Reactについて</a></li>
<li class="toctree-l2"><a class="reference internal" href="#create-react-app">create-react-appによる環境構築</a></li>
<li class="toctree-l2"><a class="reference internal" href="#next-js">Next.js</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">Reactの周辺ツールのインストールと設定</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ui">UI部品の追加</a></li>
<li class="toctree-l2"><a class="reference internal" href="#react-material-ui-typescript">React+Material UI+TypeScriptのサンプル</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reacttypescript">ReactとTypeScript</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reduxtypescript">ReduxとTypeScript</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reactredux">ReactとReduxの非同期アクセス</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">Reactの新しい書き方</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">クラスコンポーネントではなく、関数コンポーネントにする</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hooks">サードパーティのライブラリもHooksを使う</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id8">まとめ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="vue.html">Vue.jsの環境構築</a></li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="recommended.html">おすすめのパッケージ・ツール</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html">貢献者</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">仕事ですぐに使えるTypeScript</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Reactの環境構築</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/react.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="react">
<h1>Reactの環境構築<a class="headerlink" href="#react" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ウェブフロントエンドが今のJavaScript/TypeScriptの主戦場です。本章ではそのウェブフロントエンドの環境構築について紹介します。しかし、本書を書き始めたときに比べて、TypeScriptユーザーが増えるにつれて環境構築のサポートがどんどん手厚くなっているため、章の内容は減っています。そのため、1章でメジャーなフレームワークをすべて紹介することにしました。</p>
<p>本書で取り上げるのはReactとVue.jsです。React以外にReactをベースにした統合フロントエンドフレームワークとなっているNext.jsも取り上げます。
Agularは2以降からTypeScriptに書き直されて、TypeScript以外では書けなくなり、最初からTypeScriptが有効な状態でプロジェクトが作成されるため、説明は割愛します。</p>
<div class="section" id="id1">
<h2>ウェブアプリケーションにおけるビルドツールのゴール<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ウェブアプリケーションの環境構築は、ただコンパイルができるというだけではなく、TypeScriptからJavaScriptにトランスパイルされたファイルを1つや複数のチャンクにまとめるバンドラーというツールも必要です。また、開発サーバなどの設定も必要でしょう。開発サーバーはHTTPサーバーとして起動し、JavaScriptやHTML、CSSを配信するサーバーとしてブラウザからは見えます。その裏では、ファイルシステムのソースコードを監視し、変更があったら即座にビルドをして動作確認までのリードタイムを短くします。それだけではなく、その開発中のウェブサイトを見ているブラウザに対して強制リセットをしかけたり（ホットリロード）、起動中にJavaScriptのコードを差し替えたり（ホットモジュールリプレースメント）といったことを実現します。また、TypeScriptだけではなく、CSSでも、事前コンパイルでコーディングの効率をあげる方法が一般化しているため、この設定も必要でしょう。</p>
<p>この分野では数多くのツールがあります。スキルのある人は自分の好みや要件に合わせてツールを選択すると良いでしょう。TypeScriptの対応についても、最初から対応していたり、後からプラグインで拡張など、いろいろなものがあります。</p>
<p>webpackは細かくカスタマイズできますし、豊富な開発リソースで頻繁にリリースされています。ツリーシェイキングといった不要なコードを除外してサイズを小さくする機能にいち早く取り組んだり、業界をリードしています。困った時に検索すると情報も多く出てきます。一方で、TypeScript対応で開発サーバーやCSS対応など、機能を足していこうとすると設定やプラグインが増えていきます。特に、ReactのJSX構文を利用する場合は、バンドラーの処理の前段でTypeScriptをJavaScriptに変換したあとにBabelを使い、最後にバンドラーで1ファイルや複数ファイルにまとめるなど、ビルドのパイプラインが多段になりがちです。ReactやVueの環境構築ツールやNext.js、Nuxt.jsなどはwebpackを内包して、少ない設定の量で一定の機能を備えたビルド環境を整えてくれます。本書でも、webpackそのものを紹介することはしませんが、これらのツールの紹介をします。</p>
<p>他にも数多くのバンドラーがあります。webpack以降に出てきたものの多くは設定が少ない、あるいは設定ファイルが不要（ゼロコンフィギュレーション）を売りにしたものが数多くあります。Rollupは人気のあるバンドラーで、TypeScriptを使うにはプラグインが必要ですが、そうでないのであれば設定がほとんど必要ありません。RollupをベースにTypeScriptサポートを最初から組み込んだmicrobundleもあります。HTMLやCSSのビルドもできて開発サーバーも全てついてくるオールインワンでビルド速度を重視したParcelや、Go製でビルド速度に特化したesbuildもあります。一方で、カスタマイズが必要なので最初からカスタマイズ前提でCLIを提供しないFuseboxなどもあります。</p>
</div>
<div class="section" id="id2">
<h2>Reactについて<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ReactはFacebook製のウェブフロントエンドのライブラリで、宣言的UI、仮想DOMによる高速描画などの機能を備え、現在のフロントエンドで利用されるライブラリの中では世界シェアが一位となっています。Reactによって広まった宣言的UIはいまやウェブを超え、iOSのSwift UIやAndroidのJetpack Compose、Flutterなど、モバイルアプリの世界にも波及しており、このコミュニティが近年のムーブメントの発信源となることも増えています。</p>
<p>JavaScriptは組み合わせが多くて流行がすぐに移り変わっていつも環境構築させられる（ように見える）とよく言われますが、組み合わせが増えても検証されてないものを一緒に使うのはなかなか骨の折れる作業で、結局中のコードまで読まないといけなかったりとか、環境構築の難易度ばかりが上がってしまいます。特にRouterとかすべてにおいて標準が定まっていないReactはそれが顕著です。それでも、もう2013年のリリースから長い期間が経ち、周辺ライブラリも自由競争の中で淘汰されたりして、定番と言われるものもかなり定まってきています。環境構築においてもほぼ全自動で済むツール<code class="docutils literal notranslate"><span class="pre">create-react-app</span></code>が登場しましたし、オールインワンなNext.jsも利用できます。そろそろ「枯れつつあるフレームワーク」としてReactを選ぶこともできるようになると感じています。</p>
</div>
<div class="section" id="create-react-app">
<h2>create-react-appによる環境構築<a class="headerlink" href="#create-react-app" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Reactは標準で環境構築ツールcreate-react-appコマンドを提供しています。これを使って環境構築を行う場合、 <code class="docutils literal notranslate"><span class="pre">--template</span> <span class="pre">typescript</span></code> オプションをつけるとTypeScript用のプロジェクトが作成できます。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ npx create-react-app --template typescript myapp

Creating a new React app in /Users/shibukawa/work/myapp.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts...
:
Happy hacking!
</pre></div>
</div>
<p>これで開発サーバーも含めて設定は終わりです。次のコマンドが使えます。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">start</span></code>: 開発サーバー起動</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">run</span> <span class="pre">build</span></code>: ビルドしてHTML/CSS/JSファイルを生成</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">test</span></code>: jestによるテストの実行</p></li>
</ul>
<p>構築した環境は、すべてをバンドルした<code class="docutils literal notranslate"><span class="pre">react-scripts</span></code>というコマンドが開発サーバー、コンパイル、バンドルなどすべてを行います。このスクリプトはカスタマイズのポイントがなく、<code class="docutils literal notranslate"><span class="pre">tsconfig.json</span></code>があるだけです。このスクリプトはときに厄介な動きをすることもあります。例えば、<code class="docutils literal notranslate"><span class="pre">tsconfig.json</span></code>の変更を勝手に戻したりします。<code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">run</span> <span class="pre">eject</span></code>を実行すると、このスクリプトが分解されて<code class="docutils literal notranslate"><span class="pre">config</span></code>フォルダに出力されます。これを変更することで、出力先からwebpackの設定まで、細かい内容が変更できるようになります。また、どのような動作が設定されていたのかも確認できます。</p>
</div>
<div class="section" id="next-js">
<h2>Next.js<a class="headerlink" href="#next-js" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Next.jsはVercel社が開発しているReactのオールインワンパッケージです。<code class="docutils literal notranslate"><span class="pre">next</span></code>コマンドでプロジェクトを作成すると、webpackによるビルドサーバーやコンパイルに必要な設定だけではなく、フロントエンド側の便利機能のCSS in JS、シングルページアプリケーションのためのRouterなどの開発環境整備が完了した環境が一発で作成できます。バージョン9からはTypeScriptにも対応済みのプロジェクトが作成されるようになりました。よく使う部品が最初から設定されているため、ツールやライブラリの調整に手間がかからないのが良い点です。</p>
<p>デフォルトではサーバーサイドレンダリングを行うフロントエンド機能のみですが、カスタムサーバー機能を使えば、Express.jsなどのNode.jsのAPIサーバーにサーバーサイドレンダリング機能などを乗せることができます。Express.jsへの薄いラッパーになりますので、Express.jsの知識を利用して、APIサーバー機能も同一のサーバー上に追加できます。また、サーバーサイドレンダリングを使わずに静的なHTMLとJavaScriptコードを生成することも可能です。</p>
<p>Next.jsの良いところは、よく使うツールやライブラリ一式が検証された状態で最初からテストされている点にくわえ、issueのところでもアクティブな中の人がガンガン回答してくれていますし、何よりも多種多様なライブラリとの組み合わせをexampleとして公開してくれている<a class="footnote-reference brackets" href="#id4" id="id3">1</a>のが一番強いです。
お仕事でやっていて一番ありがたいのはこの相性問題の調査に取られる時間が少なくて済む点です。</p>
<p>それにプラスして、自分で設定すると相当難易度の高いサーバーサイドレンダリング、静的コンテンツの生成など、さまざまなパフォーマンス改善のための機能に取り組んでいます。</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/zeit/next.js/tree/canary/examples">https://github.com/zeit/next.js/tree/canary/examples</a></p>
</dd>
</dl>
<p>本書執筆時点のバージョンは9.4です。バージョンが変わると、方法が変わる可能性があります。</p>
<p>次のようにコマンドをタイプし、質問に答えると（プロジェクト名、標準構成で作るかサンプルを作るか）、プロジェクトフォルダが作成されます。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ npx create-next-app
</pre></div>
</div>
<p>TypeScriptには対応していますが、設定ファイルを置いて拡張子を変える必要があります。作成されたプロジェクトフォルダの中で次のコマンドをタイプします。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ touch tsconfig.json
$ npm install --save-dev typescript @types/react @types/node
</pre></div>
</div>
<p>次のコマンドが使えます。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">run</span> <span class="pre">dev</span></code>: 開発サーバー起動</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">run</span> <span class="pre">build</span></code>: ビルドして本番モードのHTML/CSS/JSファイルを生成</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">start</span></code>: ビルドしたアプリを本番モードのアプリケーションを起動</p></li>
</ul>
<p>一度、開発サーバーを起動すると、<code class="docutils literal notranslate"><span class="pre">tsconfig.json</span></code>を認知して、それに初期値を設定したり、<code class="docutils literal notranslate"><span class="pre">next-env.d.ts</span></code>というアンビエント型を書くファイルを作成します。あとは手動で、<code class="docutils literal notranslate"><span class="pre">.js</span></code>ファイルをリネームしていけば設定完了です。JSXが含まれるファイルは<code class="docutils literal notranslate"><span class="pre">.tsx</span></code>に、それ以外のファイルは<code class="docutils literal notranslate"><span class="pre">.ts</span></code>にします。</p>
<p><code class="docutils literal notranslate"><span class="pre">tsconfig.json</span></code>は今までと少し異なります。後段でBabelが処理してくれる、ということもあって、モジュールタイプはES6 modules形式、ファイルを生成することはせず、Babelに投げるので<code class="docutils literal notranslate"><span class="pre">noEmit:</span> <span class="pre">true</span></code> 。
ReactもJSX構文をそのまま残す必要があるので&quot;preserve&quot;となっています。JSで書かれたコードも一部あるので、<code class="docutils literal notranslate"><span class="pre">allowJs:</span> <span class="pre">true</span></code>でなければなりません。</p>
<p>Next.jsは<a class="reference external" href="https://github.com/css-modules/css-modules">CSS Modules</a>に対応しているため、button.tsxの場合、button.module.cssといった名前にすることで、そのファイル専用のCSSを作成できます。
もし、SCSSを使う場合は次のコマンドをタイプすると.module.scssが使えるようになります。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ npm install sass
</pre></div>
</div>
<p>詳しくはNext.jsの<a class="reference external" href="https://nextjs.org/docs/basic-features/built-in-css-support">組み込みCSSサポートページ（英語）</a>を参照してください。</p>
</div>
<div class="section" id="id5">
<h2>Reactの周辺ツールのインストールと設定<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>create-react-appの方はすでに設定済みですが、Next.jsはESLintやテストの設定が行われませんので、品質が高いコードを実装するために環境整備をしましょう。
ESLintを入れる場合は、ReactのJSXに対応させるために、<code class="docutils literal notranslate"><span class="pre">eslint-plugin-react</span></code>を忘れないようにしましょう。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># テスト関係</span>
$ npm install --save-dev jest ts-jest @types/jest

<span class="c1"># ESLint一式</span>
$ npm install --save-dev prettier eslint
　　 @typescript-eslint/eslint-plugin eslint-plugin-prettier
    eslint-config-prettier eslint-plugin-react npm-run-all
</pre></div>
</div>
<p>ESLintはJSX関連の設定や、.tsxや.jsxのコードがあったらJSXとして処理する必要があるため、これも設定に含めます。
あと、next.config.jsとかで一部Node.jsの機能をそのまま使うところがあって、CommonJSのrequireを有効にしてあげないとエラーになるので、そこも配慮します。</p>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-text">.eslintrc</span><a class="headerlink" href="#id9" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;plugins&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">&quot;prettier&quot;</span>
  <span class="p">],</span>
  <span class="nt">&quot;extends&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">&quot;plugin:@typescript-eslint/recommended&quot;</span><span class="p">,</span>
    <span class="s2">&quot;plugin:prettier/recommended&quot;</span><span class="p">,</span>
    <span class="s2">&quot;plugin:react/recommended&quot;</span>
  <span class="p">],</span>
  <span class="nt">&quot;rules&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;no-console&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&quot;prettier/prettier&quot;</span><span class="p">:</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
    <span class="nt">&quot;@typescript-eslint/no-var-requires&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nt">&quot;@typescript-eslint/indent&quot;</span><span class="p">:</span> <span class="s2">&quot;ingore&quot;</span><span class="p">,</span>
    <span class="nt">&quot;react/jsx-filename-extension&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span>
      <span class="nt">&quot;extensions&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;.ts&quot;</span><span class="p">,</span> <span class="s2">&quot;.tsx&quot;</span><span class="p">,</span> <span class="s2">&quot;.js&quot;</span><span class="p">,</span> <span class="s2">&quot;.jsx&quot;</span><span class="p">]</span>
    <span class="p">}]</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>最後にnpmから実行できるように設定します。</p>
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption"><span class="caption-text">package.json</span><a class="headerlink" href="#id10" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;scripts&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;test&quot;</span><span class="p">:</span> <span class="s2">&quot;jest&quot;</span><span class="p">,</span>
    <span class="nt">&quot;watch&quot;</span><span class="p">:</span> <span class="s2">&quot;jest --watchAll&quot;</span><span class="p">,</span>
    <span class="nt">&quot;lint&quot;</span><span class="p">:</span> <span class="s2">&quot;eslint .&quot;</span><span class="p">,</span>
    <span class="nt">&quot;fix&quot;</span><span class="p">:</span> <span class="s2">&quot;eslint --fix .&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="ui">
<h2>UI部品の追加<a class="headerlink" href="#ui" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ReactやNext.jsにはかっこいいUI部品などはついておらず、自分でCSSを書かないかぎりは真っ白なシンプルなHTMLになってしまいます。React向けによくメンテナンスされているMaterial Designのライブラリである、Material UIを入れましょう。ウェブ開発になると急に必要なパッケージが増えますね。</p>
<ul class="simple">
<li><p><a class="reference external" href="https://material-ui.com/">https://material-ui.com/</a></p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ npm install --save @material-ui/core @material-ui/icons
</pre></div>
</div>
<p>create-react-appで作成したアプリケーションの場合の設定方法は以下にサンプルがあります。</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript">https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript</a></p></li>
</ul>
<p>まずは <code class="docutils literal notranslate"><span class="pre">src/theme.tsx</span></code>をダウンロードしてきて同じパスに配置します。これがテーマ設定を行うスクリプトなので色のカスタマイズなどはこのファイルを操作することで行ます。次に<code class="docutils literal notranslate"><span class="pre">src/index.tsx</span></code>のルート直下に<code class="docutils literal notranslate"><span class="pre">ThemeProvider</span></code>コンポーネントを起き、テーマを設定します。すべてのUIはこのルートの下に作られることになりますが、このコンポーネントが先祖にいると、すべての部品が同一テーマで描画されるようになります。</p>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text">src/index.tsx</span><a class="headerlink" href="#id11" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span>import React, { StrictMode } from &#39;react&#39;;
import { render } from &#39;react-dom&#39;;
import CssBaseline from &#39;@material-ui/core/CssBaseline&#39;;
import { ThemeProvider } from &#39;@material-ui/core/styles&#39;;
import App from &#39;./App&#39;;
import * as serviceWorker from &#39;./serviceWorker&#39;;
import theme from &#39;./theme&#39;;

render(
  &lt;StrictMode&gt;
    &lt;ThemeProvider theme={theme}&gt;
      &lt;CssBaseline /&gt;
      &lt;App /&gt;
    &lt;/ThemeProvider&gt;
  &lt;/StrictMode&gt;,
  document.getElementById(&#39;root&#39;)
);
</pre></div>
</div>
</div>
<p>Next.jsも同じようなことをする必要がありますが、サーバーサイドレンダリングをする都合上、Next.jsでは少し別の設定が必要になります。下記のサイトにサンプルのプロジェクトがあります。</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/mui-org/material-ui/tree/master/examples/nextjs-with-typescript">https://github.com/mui-org/material-ui/tree/master/examples/nextjs-with-typescript</a></p></li>
</ul>
<p>行うべきは作業は3つです。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pages/_app.tsx</span></code>をダウンロードしてきて同じパスに配置</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pages/_document.tsx</span></code>をダウンロードしてきて同じパスに配置</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src/theme.tsx</span></code>をダウンロードしてきて同じパスに配置（必要に応じてカスタマイズ）</p></li>
</ul>
<p>以上により、ページ内部で自由にMaterial UIの豊富なUI部品が使えるようになります。</p>
<p>Material UI以外の選択肢としては、React専用でないWeb Components製のUI部品もあります。</p>
<ul class="simple">
<li><p>Material Web Compoennts: <a class="reference external" href="https://github.com/material-components/material-components-web-components">https://github.com/material-components/material-components-web-components</a></p></li>
<li><p>Ionic: <a class="reference external" href="https://ionicframework.com/">https://ionicframework.com/</a></p></li>
<li><p>Fast: <a class="reference external" href="https://github.com/microsoft/fast">https://github.com/microsoft/fast</a></p></li>
</ul>
</div>
<div class="section" id="react-material-ui-typescript">
<h2>React+Material UI+TypeScriptのサンプル<a class="headerlink" href="#react-material-ui-typescript" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ページ作成のサンプルです。Next.jsベースになっていますが、このサンプルに関してはcreate-react-appとの差はごく一部です。</p>
<ul class="simple">
<li><p>Next.jsはpages以下の.tsxファイルがページになります。このファイルは<code class="docutils literal notranslate"><span class="pre">pages/index.tsx</span></code>なので、<code class="docutils literal notranslate"><span class="pre">http://localhost:3000</span></code>でアクセスできます。このファイルは<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">default</span></code>でReactコンポーネントを返す必要があります。create-react-app製のコードは<code class="docutils literal notranslate"><span class="pre">src/index.tsx</span></code>がルートになっていますが、そこからインポートされている<code class="docutils literal notranslate"><span class="pre">src/App.tsx</span></code>がアプリケーションとしてはトップページなので、ここに書くと良いでしょう。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">next/head</span></code>は<code class="docutils literal notranslate"><span class="pre">&lt;head&gt;</span></code>タグを生成するコンポーネントになりますが、create-react-appの場合は<a class="reference external" href="https://www.npmjs.com/package/react-helmet">react-helmet</a>などの別パッケージが必要でしょう。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">next/link</span></code>はシングルページアプリケーションのページ間遷移を実現する特殊なリンクを生成するコンポーネントです。create-react-appでシングルページアプリケーションを実現する場合は<a class="reference external" href="https://reactrouter.com/">React Router</a>などの別パッケージが必要となります。</p></li>
</ul>
<p>TypeScriptだからといって特殊なことはほとんどなく、世間のJavaScriptのコードのほとんどそのままコピーでも動くでしょう。唯一補完が聞かない<code class="docutils literal notranslate"><span class="pre">any</span></code>が設定されていたのが<code class="docutils literal notranslate"><span class="pre">makeStyle</span></code>でした。これはCSSを生成する時にパラメータとして任意の情報を設定できるのですが、今回はMaterial UIのテーマをそのまま渡すことにしたので、<code class="docutils literal notranslate"><span class="pre">Theme</span></code>を型として設定しています。</p>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-text">pages/index.tsx</span><a class="headerlink" href="#id12" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span>import { useState } from &#39;react&#39;;
import Head from &#39;next/head&#39;;
import Link from &#39;next/link&#39;;

import { useTheme, makeStyles, Theme } from &quot;@material-ui/core/styles&quot;;
import {
  Toolbar,
  Typography,
  AppBar,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
} from &quot;@material-ui/core&quot;;

const useStyle = makeStyles({
  root: (props: Theme) =&gt; ({
    paddingTop: props.spacing(10),
    paddingLeft: props.spacing(5),
    paddingRight: props.spacing(5),
  })
});

export default function Home() {
  const [ dialogOpen, setDialogOpen ] = useState(true);
  const classes = useStyle(useTheme());
  return (
    &lt;div className={classes.root}&gt;
      &lt;Head&gt;
        &lt;title&gt;My page title&lt;/title&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, width=device-width&quot; /&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;display=swap&quot; /&gt;
      &lt;/Head&gt;
      &lt;Dialog open={dialogOpen} onClose={() =&gt; {setDialogOpen(false)}}&gt;
        &lt;DialogTitle&gt;Dialog Sample&lt;/DialogTitle&gt;
        &lt;DialogContent&gt;
          &lt;DialogContentText&gt;
            Easy to use Material UI Dialog.
          &lt;/DialogContentText&gt;
        &lt;/DialogContent&gt;
        &lt;DialogActions&gt;
          &lt;Button
            color=&quot;primary&quot;
            onClick={() =&gt; {setDialogOpen(false)}}
          &gt;OK&lt;/Button&gt;
        &lt;/DialogActions&gt;
      &lt;/Dialog&gt;
      &lt;AppBar&gt;
        &lt;Toolbar&gt;
          &lt;Typography variant=&quot;h6&quot; color=&quot;inherit&quot;&gt;
            TypeScript + Next.js + Material UI Sample
          &lt;/Typography&gt;
        &lt;/Toolbar&gt;
      &lt;/AppBar&gt;
      &lt;Typography variant=&quot;h1&quot; gutterBottom={true}&gt;
        Material-UI
      &lt;/Typography&gt;
      &lt;Typography variant=&quot;subtitle1&quot; gutterBottom={true}&gt;
        example project
      &lt;/Typography&gt;
      &lt;Typography gutterBottom={true}&gt;
        &lt;Link href=&quot;/about&quot;&gt;
          &lt;a&gt;Go to the about page&lt;/a&gt;
        &lt;/Link&gt;
      &lt;/Typography&gt;
      &lt;Button
        variant=&quot;contained&quot;
        color=&quot;secondary&quot;
        onClick={() =&gt; { setDialogOpen(true)}}
      &gt;Shot Dialog&lt;/Button&gt;
      &lt;style jsx={true}&gt;{`
        .root {
          text-align: center;
        }
      `}&lt;/style&gt;
    &lt;/div&gt;
  );
}
</pre></div>
</div>
</div>
<div class="figure align-default" id="id13">
<img alt="_images/next-sample.png" src="_images/next-sample.png" />
<p class="caption"><span class="caption-text">Next.js + Material UI + TypeScriptのサンプル</span><a class="headerlink" href="#id13" title="この画像へのパーマリンク">¶</a></p>
</div>
</div>
<div class="section" id="reacttypescript">
<h2>ReactとTypeScript<a class="headerlink" href="#reacttypescript" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Reactに限らず、近年の流行のウェブフロントエンドの実装スタイルは「コンポーネント」と呼ばれる独自タグを実装していく方法です。コンポーネントの中にもコンポーネントを書くことができます。そのコンポーネントが集まってアプリケーションになります。Reactもその例に漏れず、コンポーネントを実装していきます。</p>
<p>前節のサンプルの中にある、大文字始まりの名前のタグがそのコンポーネントです。それぞれのタグは表示されるときには分解されて、最終的にはHTML5のいつものタグに還元されます。タグなので、引数があり、子要素があります。</p>
<p>ReactはTypeScriptを使って適切に型のチェックができるようになっています。Reactはjsx構文を使って書きますが、これはTypeScriptやBabelといった処理系によってJavaScriptの普通の関数呼び出しに変換されます。React以前のライブラリなどは、テンプレートをフロントで効率よく実行するためのに、動的に関数呼び出しのコードを生成し、<code class="docutils literal notranslate"><span class="pre">eval</span></code>などを使って関数に変換したりしていました。近年ではこれらはContent-Security-Policyでエラーになる可能性があるなどの問題もあり、ビルド時にプログラム化するようになってきました。</p>
<p>Reactはこのテンプレートの変換を処理系が直々に行うので、別途変換のプリプロセッサを入れる必要がないというメリットもあるのですが、それ以上に入力パラメータの間違いなどを、普通の関数の型チェックと同様に行えるという、他のフロントエンドのフレームワークにはないメリットがあります。このチェックを最大限に生かすのも、それほど手間をかけずに行えます。次のコードはTypeScriptを用いてReactコンポーネントを作るときによく使う要素を詰め込んだものです。</p>
<ul class="simple">
<li><p>外部からの引数（props）</p></li>
<li><p>コンポーネント内で管理するステート（<code class="docutils literal notranslate"><span class="pre">useState()</span></code>）</p></li>
<li><p>初期化コード、終了コード（<code class="docutils literal notranslate"><span class="pre">useEffect()</span></code>）</p></li>
<li><p>デフォルト値</p></li>
</ul>
<div class="highlight-tsx notranslate"><div class="highlight"><pre><span></span>import React, { useState, useEffect } from &#39;react&#39;

// コンポーネントのプロパティ（タグの属性）
type Props = {
  title: string;
  description?: string;
  defaultValue: string;
};

// コンポーネントは関数
// 返り値が最終的に描画されるHTMLタグ
export function MyComponent(props: Props) {
  // propsを参照
  const { title, description } = props;
  // コンポーネント内のステート
  const [count, setCount] = useState(0);
  // ライフサイクルメソッド
  useEffect(() =&gt; {
    // 作成時（初回レンダリング直後）に呼ばれる箇所
    return () =&gt; {
      // 終了時に呼ばれる箇所
    };
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;{title}&lt;/div&gt;
      { description ? &lt;section&gt;{description}&lt;/section&gt; : null }
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{count}&lt;/button&gt;
    &lt;/div&gt;
  );
};

// 省略時のデフォルトのプロパティ
MyComponent.defaultProps = {
  defaultValue: &#39;default&#39;;
};
</pre></div>
</div>
<p>これらのうち、引数の関数のプロパティにきちんと型をつけ、<code class="docutils literal notranslate"><span class="pre">defaultProps</span></code>に値を設定すれば、利用時にエラーチェックが行われるようになります。また、関数内部の<code class="docutils literal notranslate"><span class="pre">useState()</span></code>は初期値に設定した値を元に型推論が行われます。2つの要素のタプルを返しますが、 前者は初期値と同じ型の即値が入った変数、後者はステートを更新するための関数（初期値と同じ型の1の引数のみを持つ）です。これらのおかげで、自分のコンポーネントを作成するときも、その作成したコンポーネントを利用するときも、型の恩恵が受けられます。</p>
<p>コンポーネントを外部公開する場合に、<code class="docutils literal notranslate"><span class="pre">Props</span></code>をexportする必要はありません。コンポーネントから<code class="docutils literal notranslate"><span class="pre">ComponentProps&lt;&gt;</span></code>を使って導出が可能です。もし継承拡張するニーズがあったとしても、コンポーネントだけexportしておけば利用側でアクセスできます。余計なものをexportしない方がプログラムの依存関係はよりシンプルになります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">ComponentProps</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">MyComponent</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./my-component&#39;</span><span class="p">;</span>

<span class="nx">type</span> <span class="nx">MyComponentProps</span> <span class="o">=</span> <span class="nx">ComponentProps</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">MyComponent</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>ただし、<code class="docutils literal notranslate"><span class="pre">defaultProps</span></code>で初期値を与えていてもそれは反映されません。そのため、利用側の印象と一致させるために、<code class="docutils literal notranslate"><span class="pre">defaultProps</span></code>を与える場合は、<code class="docutils literal notranslate"><span class="pre">Props</span></code>定義に<code class="docutils literal notranslate"><span class="pre">?</span></code>を追加しておきましょう。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Props</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">title</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">description?</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">defaultValue?</span>: <span class="kt">string</span><span class="p">;</span> <span class="c1">// こうしておくべきだった</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="reduxtypescript">
<h2>ReduxとTypeScript<a class="headerlink" href="#reduxtypescript" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Reactの周辺のライブラリの作者の中にはTypeScriptを使わない人が多くいました。Reactは元々Facebookが開発していたflowtypeを使うことが多かったり、ReactのJavaScriptの記述法がかなりトリッキーだったり、と理由はいろいろ考えられます。その後、MicrosoftがReactを大々的に利用するように宣言し、TypeScriptの機能もかなり充実しました。近年ではTypeScriptの型定義ファイルが最初から付属するようになったり、TypeScriptで再実装されたり、TypeScriptとの親和性がどんどん上がっています。</p>
<p>Reduxはアプリケーション内部で横断的に利用したいデータを保持したり、その更新を行うための補助ライブラリです。データの更新にともない、必要な画面更新だけを効率的に行えるようにもしてくれます。大規模なアプリケーションではよく活用されていました。そのRedux本体も、TypeScriptで適切に型をつけていこうとするとかなり頭と手を使う必要がありましたが、公式サポートライブラリのRedux-Toolkitは、TypeScriptとの親和性が極めて高くなりました。素のReduxをこれから扱う理由は特にないので、本書ではRedux-Toolkit経由でのReduxの操作について紹介します。</p>
<p>Reduxはストアと呼ばれる中央のデータ庫を持ちます。データに変更を加えるためのreducerと呼ばれる変換ロジックを実装します。標準のReduxを使う場合は、reducerのみを実装します。この関数の返り値がステートになります。データの保管そのものはReduxが行い、開発者が触ることはできません。必要に応じてreducerをReduxが実行し、その結果をReduxが管理するという構成です。</p>
<p>このreducerをトリガーするのに必要なのが、アクションと呼ばれるデータでした。これを<code class="docutils literal notranslate"><span class="pre">dispatch()</span></code>という関数に投げ込むことでreducerが起動され、そのアクションに応じてデータを書き換えていました。</p>
<p>しかし、まずJavaScriptの文化で、アクションクリエーターというアクションを作る関数を作っていました。この場合、型をつけるにはreducerの引数にはすべてのアクションの型（アクションクリエーターの返り値の型）の合併型を作る必要がありました。この「すべての」というのが大きなアプリケーションになると依存関係が循環しないように気をつけたり、漏れなく型を合成してあげないといけなかったりと、型のために人間が行う作業が膨大でした。多くの人が「Reduxに型をつけるには？」という文章を書いたりしましたが、その後、Reduxが公式で出してきた解答がRedux-Toookitでした。</p>
<p>Redux-Toolkitは次のような実装になります。スライスというステートとreducer、アクションクリエーターがセットになったオブジェクトを作成します。Reducerの引数のstateは<code class="docutils literal notranslate"><span class="pre">Readonly&lt;&gt;</span></code>をつけておくと、デバッグで問題の追跡が難しい不測の事態が発生するのを未然に防げます。</p>
<div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-text">スライスを作成</span><a class="headerlink" href="#id14" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">createSlice</span><span class="p">,</span> <span class="nx">configureStore</span><span class="p">,</span> <span class="nx">PayloadAction</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;@reduxjs/toolkit&#39;</span><span class="p">;</span>

<span class="c1">// stateの型定義</span>
<span class="kr">export</span> <span class="nx">type</span> <span class="nx">State</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">count</span>: <span class="kt">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 初期状態。インラインで書いても良いですが・・・・</span>
<span class="kr">const</span> <span class="nx">initialState</span>: <span class="kt">State</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">count</span>: <span class="kt">0</span>
<span class="p">};</span>

<span class="c1">// createSliceでreducerとactionを同時に定義</span>
<span class="kr">const</span> <span class="nx">counterSlice</span> <span class="o">=</span> <span class="nx">createSlice</span><span class="p">({</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;counter&#39;</span><span class="p">,</span>
  <span class="nx">initialState</span><span class="p">,</span>
  <span class="nx">reducers</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">incrementCounter</span><span class="o">:</span> <span class="p">(</span><span class="nx">state</span>: <span class="kt">Readonly</span><span class="o">&lt;</span><span class="nx">State</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">action</span>: <span class="kt">PayloadAction</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="p">...</span><span class="nx">state</span><span class="p">,</span>
      <span class="nx">count</span>: <span class="kt">state.count</span> <span class="o">+</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="nx">decrementCounter</span><span class="o">:</span> <span class="p">(</span><span class="nx">state</span>: <span class="kt">Readonly</span><span class="o">&lt;</span><span class="nx">State</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">action</span>: <span class="kt">PayloadAction</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="p">...</span><span class="nx">state</span><span class="p">,</span>
      <span class="nx">count</span>: <span class="kt">state.count</span> <span class="o">-</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">,</span>
    <span class="p">}),</span>
  <span class="p">},</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
<p>スライス自体はReduxのストアを作る材料ではありますが、もうひとつ、アクションクリエーターのオブジェクトも結果に格納されています。これをエクスポートしてコンポーネントから利用できるようにします。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// action creatorをスライスから取り出して公開可能</span>
<span class="c1">// dispatch経由でコンポーネントのコードから呼び出せる</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="p">{</span> <span class="nx">incrementCounter</span><span class="p">,</span> <span class="nx">decrementCounter</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">counterSlice</span><span class="p">.</span><span class="nx">actions</span><span class="p">;</span>
</pre></div>
</div>
<p>スライスからストアを作るには<code class="docutils literal notranslate"><span class="pre">configureStore()</span></code>を使います。管理対象が少なければ、スライス作成からストア作成まで１ファイルでやりきってもいいでしょう。複雑になる場合は、スライス作成部分をファイルに切り出しましょう。</p>
<div class="literal-block-wrapper docutils container" id="id15">
<div class="code-block-caption"><span class="caption-text">スライスからストアを作成</span><a class="headerlink" href="#id15" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// sliceからstoreを作る</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">configureStore</span><span class="p">({</span>
  <span class="nx">reducer</span>: <span class="kt">counterSlice.reducer</span><span class="p">,</span>
<span class="p">});</span>

<span class="c1">// 複数のsliceからstoreを作るにはreducerにオブジェクトを渡せばOK</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">configureStore</span><span class="p">({</span>
  <span class="nx">reducer</span><span class="o">:</span> <span class="p">{</span>
     <span class="nx">counter</span>: <span class="kt">counterSlice.reducer</span><span class="p">,</span>
     <span class="nx">primenumber</span>: <span class="kt">primenumberSlice.reducer</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<p>さらに型チェックを強固にするために、コンポーネントとのインタフェースとなる関数群にもきちんと型をつけておきます。上記の<code class="docutils literal notranslate"><span class="pre">store</span></code>を作るファイルで一緒にやってしまうと良いでしょう。</p>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-text">利用側との接点となる型情報付き関数を生成</span><a class="headerlink" href="#id16" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span>
  <span class="nx">useSelector</span> <span class="kr">as</span> <span class="nx">useReduxSelector</span><span class="p">,</span>
  <span class="nx">TypedUseSelectorHook</span><span class="p">,</span>
<span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react-redux&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="nx">type</span> <span class="nx">RootState</span> <span class="o">=</span> <span class="nx">ReturnType</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">useSelector</span>: <span class="kt">TypedUseSelectorHook</span><span class="o">&lt;</span><span class="nx">RootState</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">useReduxSelector</span><span class="p">;</span>
<span class="kr">export</span> <span class="nx">type</span> <span class="nx">AppDispatch</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Reduxとの大きな違いは、内部で管理するステートの初期値とその型を明示的に宣言できるようになったことです。Reduxではreducerの引数とそのデフォルト値が初期値でした。いろいろなところで活用しますし、ステートの加工にあたってもチェックや補完が欲しいところなので、補完も期待通りに行われますし、エラーメッセージもわかりやすくなります。</p>
<p><code class="docutils literal notranslate"><span class="pre">reducers</span></code>の中身が実際に値を加工する操作が入っています。この関数では変更前のステートを受け取り、それに値を設定して関数の返り値として返します。Reduxと違い、1つの関数の中に自分で<code class="docutils literal notranslate"><span class="pre">switch</span></code>文を書くのではなく、このオブジェクトのキー単位で操作の単位として独立しています。</p>
<p>アプリケーション側との接点は2か所です。アプリケーション全体の設定と、値を利用したいコンポーネントです。</p>
<div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-text">アプリ全体で一カ所、storeを設定</span><a class="headerlink" href="#id17" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-tsx notranslate"><div class="highlight"><pre><span></span>import { store } from &#39;../redux/store&#39;;
import { Provider } from &#39;react-redux&#39;;

function App() {
  return (
    &lt;Provider store={store}&gt;
      &lt;Router&gt;
        &lt;Switch&gt;
          &lt;Route exact path=&quot;/&quot;&gt;&lt;RootPage /&gt;&lt;/Route&gt;
          &lt;Route path=&quot;/edit&quot;&gt;&lt;EditPage /&gt;&lt;/Route&gt;
        &lt;/Switch&gt;
      &lt;/Router&gt;
    &lt;/Provider&gt;
  )
}
</pre></div>
</div>
</div>
<p>各コンポーネントでは<code class="docutils literal notranslate"><span class="pre">useSelector()</span></code>と<code class="docutils literal notranslate"><span class="pre">useDispatch()</span></code>を使ってストアへの読み書きを行ます。</p>
<div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text">Reduxのステートを利用する関数側</span><a class="headerlink" href="#id18" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span>// Reduxの提供のuseDispatch
import { useDispatch } from &#39;react-redux&#39;;
// スライス側からアクションクリエーター
import { incrementCounter } from &#39;../redux/counterslice&#39;;
// ストア側からは型をつけたuseSelectorとDispatch用の型定義
import { useSelector, AppDispatch } from &#39;../redux/store&#39;;

export function MyComponent() {
  const dispatch = useDispatch&lt;AppDispatch&gt;();
  const counter = useSelector(state =&gt; state.counter);
  return (
    &lt;div&gt;
      &lt;!-- ストアのステートを利用 --&gt;
      &lt;h1&gt;count: {counter.count}&lt;/h1&gt;
      &lt;!-- dispatchでストアに変更を加える --&gt;
      &lt;button onClick={() =&gt; dispatch(incrementCounter(10))} /&gt;
    &lt;/div&gt;
  )
}
</pre></div>
</div>
</div>
<p>要注意なポイントは、スライスの名前です。複数のスライスをまとめてReduxの最終的なステートを作り上げますが、この名前がかぶっていると、変更していないはずなのにいつのまにか値が変更されていたりといったトラブルが発生します。</p>
</div>
<div class="section" id="reactredux">
<h2>ReactとReduxの非同期アクセス<a class="headerlink" href="#reactredux" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Reactの基本の書き方とRedux-Toolkitを使って型チェックが完全な形で行われるようになりました。サーバーサイドレンダリングの仕組みやstyled-componentを使ったスタイリング、Routerによるシングルページアプリケーションのページ切り替えなど、追加の情報や便利ライブラリは別にありますが、Reactに関する最新の基礎知識はほぼこれでカバーできたと言えます。</p>
<p>しかし、もう1つ触れておかなければならないことがあります。それが非同期のデータアクセスです。</p>
<p>画面の表示に必要なデータの取得や結果の格納でサーバーアクセスが必要になることがあります。サーバーアクセスが一切ないウェブフロントエンドはあまりないでしょう。静的サイトジェネレータから呼び出す場合はまたそちらの作法がありますが、今回は通常のウェブアプリケーションのフロントエンドの説明を行ます。</p>
<p>まず表示に利用する情報の取得です。コンポーネント単体で取得、あるいはRedux経由の利用があります。一番簡単なコンポーネント内部で完結する方法を紹介します。コンポーネント内部で呼び出す場合は<code class="docutils literal notranslate"><span class="pre">useEffect()</span></code>を利用します。注意点としては、<code class="docutils literal notranslate"><span class="pre">useEffect()</span></code>にはasync関数を渡すことができない点です。後始末の処理を<code class="docutils literal notranslate"><span class="pre">return</span></code>で返すというAPI設計の制約による気がしますが、利用側としては従わざるをえません。asyncな関数を作り、それを呼び出します。</p>
<p>このコードは、ブラウザ標準APIの<code class="docutils literal notranslate"><span class="pre">fetch</span></code>を使い、最終的に<code class="docutils literal notranslate"><span class="pre">useState()</span></code>提供の関数<code class="docutils literal notranslate"><span class="pre">setData()</span></code>で取得してきた値を格納しています。もしエラーがあれば、同様に<code class="docutils literal notranslate"><span class="pre">setShowErrorDialog()</span></code>に格納しています。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// サーバーデータ</span>
<span class="kr">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">setData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">({</span><span class="nx">loaded</span>: <span class="kt">false</span><span class="p">}</span> <span class="kr">as</span> <span class="nx">Data</span><span class="p">);</span>
<span class="c1">// エラーダイアログ表示用ステート</span>
<span class="kr">const</span> <span class="p">[</span><span class="nx">showErrorDialog</span><span class="p">,</span> <span class="nx">setShowErrorDialog</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>

<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">async</span> <span class="kd">function</span> <span class="nx">getData() {</span>
    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api/getdata&#39;</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">data</span>: <span class="kt">Data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="nx">data</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span> <span class="kr">as</span> <span class="nx">Data</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">setShowErrorDialog</span><span class="p">(</span><span class="sb">`parse error </span><span class="si">${</span><span class="nx">e</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">setShowErrorDialog</span><span class="p">(</span><span class="sb">`server access error`</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">setData</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">getData</span><span class="p">();</span>
<span class="p">},</span> <span class="p">[]);</span>
</pre></div>
</div>
<p>Redux-Toolkitのreducersにはそのままでは非同期処理が書けません。<code class="docutils literal notranslate"><span class="pre">createAsyncThunk()</span></code>を使い、それを<code class="docutils literal notranslate"><span class="pre">extraReducers</span></code>の中で登録します。</p>
<div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-text">非同期のreducer</span><a class="headerlink" href="#id19" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">createAsyncThunk</span> <span class="p">}</span> <span class="kr">import</span> <span class="s1">&#39;@reduxjs/toolkit&#39;</span><span class="p">;</span>

<span class="nx">type</span> <span class="nx">fetchLastCounterReturnType</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">count</span>: <span class="kt">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">fetchLastCounter</span> <span class="o">=</span> <span class="nx">createAsyncThunk</span><span class="o">&lt;</span><span class="nx">fetchLastCounterReturnType</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="s1">&#39;lastcount/fetch&#39;</span><span class="p">,</span>
  <span class="nx">async</span> <span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">thunk</span><span class="p">)</span><span class="o">:</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nx">fetchLastCounterReturnType</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api/lastcount&#39;</span><span class="p">,</span> <span class="p">{</span>
       <span class="nx">credentials</span><span class="o">:</span> <span class="s1">&#39;same-origin&#39;</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">return</span> <span class="p">(</span><span class="nx">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span> <span class="kr">as</span> <span class="nx">fetchLastCounterReturnType</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;fetch count error&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="kr">const</span> <span class="nx">counterSlice</span> <span class="o">=</span> <span class="nx">createSlice</span><span class="p">({</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;counter&#39;</span><span class="p">,</span>
  <span class="nx">initialState</span><span class="p">,</span>
  <span class="nx">reducers</span><span class="o">:</span> <span class="p">{},</span>
  <span class="nx">extraReducers</span>: <span class="kt">builder</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">builder</span><span class="p">.</span><span class="nx">addCase</span><span class="p">(</span><span class="nx">fetchLastCounter</span><span class="p">.</span><span class="nx">fullfilled</span><span class="p">,</span>
      <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
          <span class="p">...</span><span class="nx">state</span><span class="p">,</span>
          <span class="nx">count</span>: <span class="kt">action.payload.count</span>
        <span class="p">};</span>
      <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
<p>これも、<code class="docutils literal notranslate"><span class="pre">dispatch(fetchLastCounter())</span></code>のように呼び出せます。この非同期アクションに引数を設定したい場合は、createAsyncThunkの2つ目の型パラメータに引数を設定します。型パラメータに入れずにasyncの関数側の<code class="docutils literal notranslate"><span class="pre">arg</span></code>にだけ型を付けようとしてもエラーになるので注意してください。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">fetchLastCounterArgType</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">counterName</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">fetchLastCounter</span> <span class="o">=</span> <span class="nx">createAsyncThunk</span><span class="o">&lt;</span>
  <span class="nx">fetchLastCounterReturnType</span><span class="p">,</span>
  <span class="nx">fetchLastCounterArgType</span>
<span class="o">&gt;</span><span class="p">(</span>
  <span class="s1">&#39;lastcount/fetch&#39;</span><span class="p">,</span>
  <span class="nx">async</span> <span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">thunk</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 略</span>
  <span class="p">}</span>
<span class="p">);</span>
</pre></div>
</div>
<p>この非同期アクションからReduxのストアに値を設定する方法が2つあります。1つが上記の登録方法で紹介した<code class="docutils literal notranslate"><span class="pre">extraReducers</span></code>です。<code class="docutils literal notranslate"><span class="pre">pending</span></code>、<code class="docutils literal notranslate"><span class="pre">fulfilled</span></code>、<code class="docutils literal notranslate"><span class="pre">error</span></code>の3つの状態に対して<code class="docutils literal notranslate"><span class="pre">reducer</span></code>が書けます。それぞれ、実行開始直後、完了後、エラー発生のときに呼ばれます。これが一番簡単です。</p>
<p>もう片方が、データ格納用のreducerを別個に作成し、非同期アクションから呼び出す方法です。2つ目の引数の<code class="docutils literal notranslate"><span class="pre">thunk</span></code>には<code class="docutils literal notranslate"><span class="pre">getState()</span></code>や<code class="docutils literal notranslate"><span class="pre">dispatch()</span></code>といった、Redux本体とアクセスするメソッドがあります。これらを使い、ステートの状態を取得しつつ、<code class="docutils literal notranslate"><span class="pre">dispatch()</span></code>で個別に作成したreducerに呼ぶことで、ステートに結果を書き込むことができます。基本的には前者の方法で済むことが多いでしょう。</p>
<p>これらの非同期アクションを呼び出して結果をコンポーネントから利用する方法は2つあります。ひとつはすでに紹介した<code class="docutils literal notranslate"><span class="pre">useSelector()</span></code>経由で情報を取得してくる方法です。もう1つは、結果を直接受け取る方法です。後者は<code class="docutils literal notranslate"><span class="pre">dispatch()</span></code>の結果を<code class="docutils literal notranslate"><span class="pre">unwrapResult()</span></code>に渡すことで、正常終了したときの結果が得られます。</p>
<div class="literal-block-wrapper docutils container" id="id20">
<div class="code-block-caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">unwrapResult</span></code>を使った例</span><a class="headerlink" href="#id20" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">unwrapResult</span> <span class="p">}</span> <span class="kr">import</span> <span class="s1">&#39;@reduxjs/toolkit&#39;</span><span class="p">;</span>

<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">async</span> <span class="kd">function</span> <span class="nx">getData() {</span>
    <span class="kr">const</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">unwrapResult</span><span class="p">(</span><span class="nx">await</span> <span class="nx">dispatch</span><span class="p">(</span><span class="nx">fetchLastCounter</span><span class="p">()));</span>
    <span class="nx">dispatch</span><span class="p">(</span><span class="nx">fetchUpdateLog</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">count</span><span class="p">,</span> <span class="nx">username</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="nx">getData</span><span class="p">();</span>
<span class="p">},</span> <span class="p">[]);</span>
</pre></div>
</div>
</div>
<p>Reactの昔からよく発生するコーディングのミスとして、ステートへ格納した直後に結果を読み出そうとしてもまだ更新されていない、というものがあります。<code class="docutils literal notranslate"><span class="pre">useState()</span></code>のセッターで設定したステートやReduxのストアの状態は、次の更新時まで変更されません。更新してしまうと、一つのレンダリング関数の中で、変数の状態が複数存在する可能性が発生してしまい、整合性を保つのが困難になります。しかし、その副作用として、結果を更新したものを使う場合に、次の更新まで待たなければならなくなります。</p>
<p>しかし、非同期の呼び出しがきちんと期待通りに呼ばれるかどうかというのはうまく動かなかった時の問題追跡が困難です。そのため、サーバーの結果を受けて再度何かサーバーアクセスを行う場合などは、途中でReactの再描画を待つのではなく、一つのasync関数の中で処理を完結させる方がバグが出にくく、コードの行数も短くなり、見通しの良いコードになります。</p>
<p>次のコードはぱっと見たときに<code class="docutils literal notranslate"><span class="pre">useEffect()</span></code>同士の依存関係が見えません。コードを読み解くと、<code class="docutils literal notranslate"><span class="pre">fetchLastCounter()</span></code>の結果がReduxのステートに格納され、その数値が書き換わったことで、2つ目の<code class="docutils literal notranslate"><span class="pre">useEffect()</span></code>が呼ばれることが分かりますが、お世辞にも分かりやすいとは言えません。TypeScriptの可視性のすぐれた<code class="docutils literal notranslate"><span class="pre">async</span></code>/<code class="docutils literal notranslate"><span class="pre">await</span></code>を使うべきです。</p>
<div class="literal-block-wrapper docutils container" id="id21">
<div class="code-block-caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">unwrapResult</span></code>を使わない例</span><a class="headerlink" href="#id21" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">counter</span> <span class="o">=</span> <span class="nx">useSelector</span><span class="p">(</span><span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">counter</span><span class="p">);</span>

<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">dispatch</span><span class="p">(</span><span class="nx">fetchLastCounter</span><span class="p">());</span>
<span class="p">},</span> <span class="p">[]);</span>

<span class="c1">// 分割されたuseEffect</span>
<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">dispatch</span><span class="p">(</span><span class="nx">fetchUpdateLog</span><span class="p">(</span><span class="nx">counter</span><span class="p">.</span><span class="nx">count</span><span class="p">,</span> <span class="nx">username</span><span class="p">));</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">counter</span><span class="p">.</span><span class="nx">count</span><span class="p">]);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id6">
<h2>Reactの新しい書き方<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Reactは歴史のあるコンポーネントで、途中でいくつも機能追加が行われたり改善されています。1つのことを実現するのに新旧何通りもやり方が提供されていたりします。新しい書き方が作られるのは、もちろん、そちらの方がミスが少なかったり、コードが短くなったりと改善が見込まれるからです。Reactの場合はTypeScript的にも優しい書き方となっているため、もし古いコーディング規約に従っている場合は新しい書き方に整理していくと良いでしょう。</p>
<p>2019年2月にリリースされたReact 16.8のHooksにより、新しい書き方に大々的に移行可能になりました。もしこれ以前から続いているプロジェクトの場合、新しくつくるコンポーネントや、改修を行うコンポーネントから徐々に移行していくと良いでしょう。</p>
<div class="section" id="id7">
<h3>クラスコンポーネントではなく、関数コンポーネントにする<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>まずは古いTypeScript以前の書き方です。お決まりの書き方だけでもかなりの行数になってしまいます。</p>
<div class="literal-block-wrapper docutils container" id="id22">
<div class="code-block-caption"><span class="caption-text">古い書き方</span><a class="headerlink" href="#id22" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span>import React, { Component } from &quot;react&quot;;
import propTypes from &quot;prop-types&quot;;

class MyComponent extends Component {
    constructor(props) {
        super(props);
        this.state = {
            count: 0;
        }
        this.onClick = this.onClick.bind(this);
    }

    componentDidMount() {
        // サーバーアクセスなどのマウント後に実行したいコードはここ
    }

    componentWillUnmount() {
        // 削除前に実行したいコードはここ
    }

    onClick() {
        this.setState({
            count: this.state.count + 1;
        });
        this.Props.onUpdated(this.state.count + 1);
    }

    render() {
        return (
            &lt;div className=&quot;panel&quot;&gt;
                &lt;div className=&quot;message&quot;&gt;
                    &lt;button onClick={this.onClick}&gt;{this.props.label}&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}

MyComponent.propTypes = {
    label: PropTypes.string
    onUpdated: PropTypes.func
}

MyComponent.defaultProps = {
    label: &quot;押して下さい&quot;
};
</pre></div>
</div>
</div>
<p>これ以降、JavaScriptやTypeScriptへの機能追加により、何段階か書き方の改善がありました。コンストラクタで<code class="docutils literal notranslate"><span class="pre">onClick</span></code>をbindしなおさずに、class定義の中で代入できるようになったので、アロー演算子を使っているかもしれませんし、TypeScript化で<code class="docutils literal notranslate"><span class="pre">Component</span></code>の型変数でPropsやStateの型変数を設定するようになっているかもしれません。</p>
<div class="literal-block-wrapper docutils container" id="id23">
<div class="code-block-caption"><span class="caption-text">ほどほどに古い書き方</span><a class="headerlink" href="#id23" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">Props</span> <span class="p">{</span>
    <span class="nx">label</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="nx">onUpdated</span><span class="o">:</span> <span class="p">(</span><span class="nx">count</span>: <span class="kt">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">State</span> <span class="p">{</span>
    <span class="nx">counter</span>: <span class="kt">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// TypeScriptで型定義</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">MyComponent</span> <span class="kr">extends</span> <span class="nx">Component</span><span class="o">&lt;</span><span class="nx">Props</span><span class="p">,</span> <span class="nx">State</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// コンストラクタではなく、クラス定義の中で代入文</span>
    <span class="kr">private</span> <span class="nx">state</span>: <span class="kt">State</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">counter</span>: <span class="kt">0</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="c1">// アロー演算子でイベントハンドラ実装</span>
    <span class="kr">private</span> <span class="nx">onClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span><span class="nx">counter</span>: <span class="kt">this.state.counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">});</span>
    <span class="p">}</span>
    <span class="nx">render() {</span>
        <span class="c1">// :ここは同じ</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>古い書き方でTypeScriptを使わなくても、Reactレベルでさまざまなチェック機構が提供されており開発は便利ではありました。ただし、<code class="docutils literal notranslate"><span class="pre">state</span></code>の変更処理（<code class="docutils literal notranslate"><span class="pre">setState()</span></code>呼び出し）をした直後にはまだインスタンス変数の<code class="docutils literal notranslate"><span class="pre">this.state</span></code>が変更されておらず、状態がおかしくなってしまう、という問題があったり、イベントハンドラをJSXに渡すときに、thisの束縛を忘れてイベントが発火した後にエラーになるといったミスがおきやすい素地がありました。</p>
<p>現在主流になっているのが関数コンポーネントです。当初は状態を持たないコンポーネントのみだったため、クラスコンポーネントからの完全移行は大変でしたが、Hookという機能が追加されてクラスコンポーネントを完璧に置き換えられるようになりました。関数コンポーネントは状態管理をReact側におまかせして、<code class="docutils literal notranslate"><span class="pre">render()</span></code>のみにしたような書き方です。だいぶ、縦にも横にも圧縮されたことがわかります。</p>
<div class="literal-block-wrapper docutils container" id="id24">
<div class="code-block-caption"><span class="caption-text">新しい書き方</span><a class="headerlink" href="#id24" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span>import React, { useState, useEffect } from &quot;react&quot;;

type Props = {
    label?: string;
    onUpdated: (count: number) =&gt; void;
};

export function MyComponent(props: Props) {
    const [count, setCount] = useState(0);
    const {label, onUpdate} = props;

    useEffect(() =&gt; {
        // サーバーアクセスなどのマウント後に実行したいコードはここ
        return () =&gt; {
            // 削除前に実行したいコードはここ
        }
    }, []);

    function onClick() {
        setCount(count + 1);
        onUpdated(count + 1);
    }

    return (
        &lt;div className=&quot;panel&quot;&gt;
            &lt;div className=&quot;message&quot;&gt;
                &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

MyComponent.defaultProps = {
    label: &quot;押して下さい&quot;
};
</pre></div>
</div>
</div>
<p>一番短くなってミスがおきにくくなったのは<code class="docutils literal notranslate"><span class="pre">state</span></code>周りです。<code class="docutils literal notranslate"><span class="pre">useState()</span></code>に初期値を渡すと、現在の値を保持する変数と、変更する関数がペアで帰ってきます。初期値から型推論で設定されるため、Stateの型定義を外で行う必要はなくなります。<code class="docutils literal notranslate"><span class="pre">setState()</span></code>で変更したものが直後に変更されているはず、と誤解されることもなくなりました。もう一度レンダリングが実行されないと変数の値が変更されないのは<code class="docutils literal notranslate"><span class="pre">useState()</span></code>の宣言を見ればあきらかです。</p>
<p>イベントハンドラの<code class="docutils literal notranslate"><span class="pre">this</span></code>の束縛もなくなります。もはや単なる関数であって、オブジェクトではないため、<code class="docutils literal notranslate"><span class="pre">this</span></code>を扱う必要もなくなります。横方向に圧縮されたのは<code class="docutils literal notranslate"><span class="pre">this.</span></code>がたくさん省略されたからです。</p>
<p>いくつかのライフサイクルメソッドが削除されたり、名前が変わったりはありますが、以前のコードもそのまま動きますので、全部を一度に移行する必要はありません。</p>
</div>
<div class="section" id="hooks">
<h3>サードパーティのライブラリもHooksを使う<a class="headerlink" href="#hooks" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>関数コンポーネント自体もコードを短くする効能がありますが、新しいHooksスタイルにより、サードパーティのライブラリの組み込みも簡単になります。残念ながら、Hooksスタイルの関数は関数コンポーネントでしか利用できませんので、前述の関数コンポーネントへの書き換えがまず必要になります。</p>
<p>例えば、React-RouterやReduxとの接続は、コンポーネントをラップしてpropsに要素を追加する関数呼び出しが必要でした。ユーザーコード側では、サードパーティのライブラリから何かしら情報をもらったり、サードパーティのライブラリの機能を呼び出しするには、<code class="docutils literal notranslate"><span class="pre">props</span></code>経由で扱う必要があり、この特殊なラッパーは<code class="docutils literal notranslate"><span class="pre">props</span></code>に新しい属性を増やす役割を果たしていました。しかし、ユーザーコード側でも<code class="docutils literal notranslate"><span class="pre">propsTypes</span></code>にこれを追加する必要があったりと、たくさんの転記作業が必要でした。コンポーネントの外の状態まで気を配る必要がありました。</p>
<div class="literal-block-wrapper docutils container" id="id25">
<div class="code-block-caption"><span class="caption-text">古いReact-Routerのラッパースタイルの書き方</span><a class="headerlink" href="#id25" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Component</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">withRouter</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;react-router-dom&quot;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kr">class</span> <span class="nx">MyComponent</span> <span class="kr">extends</span> <span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">onClick</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// ページ遷移</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">history</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot;/new-path&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// :</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// サードパーティを使う側に知識が必要なポイント</span>
<span class="nx">MyComponent</span><span class="p">.</span><span class="nx">props</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">history</span><span class="o">:</span> <span class="nx">PropTypes</span><span class="p">.</span><span class="nx">object</span><span class="p">.</span><span class="nx">isRequired</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// ここでラップ！</span>
<span class="kr">const</span> <span class="nx">MyComponent</span> <span class="o">=</span> <span class="nx">withRouter</span><span class="p">(</span><span class="nx">MyComponent</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Hooksに対応したReact-Routerのv5移行であればコンポーネントの中で履歴を触るためにコンポーネントの外にまで手を加える（ラップしたりPropsを変更する）必要はなくなりました。ここでも、縦にも横にも短くなったことがわかるでしょう。React-Routerの機能にアクセスするための壮大な準備コードが不要になりました。</p>
<div class="literal-block-wrapper docutils container" id="id26">
<div class="code-block-caption"><span class="caption-text">新しい履歴へのアクセス方法</span><a class="headerlink" href="#id26" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">React</span> <span class="nx">from</span> <span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">useHistory</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;react-router-dom&quot;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">(</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">history</span> <span class="o">=</span> <span class="nx">useHistory</span><span class="p">();</span>

    <span class="nx">onClick() {</span>
        <span class="nx">history</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot;/new-path&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="c1">// :</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>よく不要論が取り沙汰されるReduxも、Reduxのストアにアクセスしたり、変更のために<code class="docutils literal notranslate"><span class="pre">dispatch</span></code>を呼ぶときにその準備コードが多くなる問題がありました。次のコードは、コンポーネント定義自体は全部省略して空ですが、これだけの準備コードが必要でした。</p>
<div class="literal-block-wrapper docutils container" id="id27">
<div class="code-block-caption"><span class="caption-text">Reduxの古い書き方</span><a class="headerlink" href="#id27" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Component</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">connect</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;react-redux&quot;</span>

<span class="kr">class</span> <span class="nx">MyComponent</span> <span class="kr">extends</span> <span class="nx">Component</span> <span class="p">{</span>
   <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// PropTypesへの追加が必要</span>
<span class="nx">MyComponent</span><span class="p">.</span><span class="nx">porpTypes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">counter</span><span class="o">:</span> <span class="nx">PropTypes</span><span class="p">.</span><span class="nx">object</span><span class="p">,</span>
    <span class="nx">onClick</span><span class="o">:</span> <span class="nx">PropTypes</span><span class="p">.</span><span class="nx">func</span><span class="p">,</span>
    <span class="nx">dispatch</span><span class="o">:</span> <span class="nx">PropTypes</span><span class="p">.</span><span class="nx">func</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// このマッピング関数の定義は必要</span>
<span class="kd">function</span> <span class="nx">mapStateToProps</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">counter</span><span class="o">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">reducer</span><span class="p">.</span><span class="nx">counter</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// connectでpropsにdispatchが増えるので、connectの2つめの</span>
<span class="c1">// このマッピングは使わずにdispatchをコンポーネント内部で呼び出す</span>
<span class="c1">// ことも可能</span>
<span class="kd">function</span> <span class="nx">mapDispatchToProps</span><span class="p">(</span><span class="nx">dispatch</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="c1">// アクションはオブジェクトそのままではなくアクションクリエータとして切り出されている場合も</span>
        <span class="nx">onClick</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">dispatch</span><span class="p">({</span>
            <span class="nx">type</span><span class="o">:</span> <span class="nx">Actions</span><span class="p">.</span><span class="nx">DISPATCH_EVENT</span><span class="p">,</span>
            <span class="nx">hoge</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="p">}),</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">MyComponent</span> <span class="nx">connect</span><span class="p">(</span><span class="nx">mapStateToProps</span><span class="p">,</span> <span class="nx">mapDispatchToProps</span><span class="p">)(</span><span class="nx">Test</span><span class="p">);</span>
<span class="kr">export</span> <span class="nx">MyComponent</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">dispatch()</span></code>のマッピングはしていませんが、<code class="docutils literal notranslate"><span class="pre">dispatch()</span></code>やReduxのストアへのアクセスは2つのHooksスタイルの関数で完了します。劇的ですね。Reduxのストア定義自体も、本章の中で紹介したRedux-Toolkitを使うことで大幅に短く書けるようになりました。</p>
<div class="literal-block-wrapper docutils container" id="id28">
<div class="code-block-caption"><span class="caption-text">Reduxの新しい書き方</span><a class="headerlink" href="#id28" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">useDispatch</span><span class="p">,</span> <span class="nx">useSelector</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react-redux&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">MyComponent() {</span>
    <span class="kr">const</span> <span class="nx">dispatch</span> <span class="o">=</span> <span class="nx">useDispatch</span><span class="p">();</span>
    <span class="kr">const</span> <span class="nx">counter</span> <span class="o">=</span> <span class="nx">useSelector</span><span class="p">(</span><span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">counter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>なお、<code class="docutils literal notranslate"><span class="pre">useDispatch()</span></code>と<code class="docutils literal notranslate"><span class="pre">useSelector()</span></code>ですが、本章の中で触れた通りに、Redux-Toolkitのストアの定義のついでに型付けをしておくと、コンポーネント内部でも型の恩恵を最大限に得ることができます。</p>
<p>React-Routerにしても、Reduxにしても、はたまたスタイル定義のライブラリだったりにしても、一種類だけの適用であれば、探せばサンプルコードや情報も出てきますし、初心者でも調べ物しながらなんとかできる範囲ではありますが、複数のコンポーネントが登場し始めて設定周りのコードが絡みだすと、情報が減り、トラブル発生時のシューティングが難しくなります。コードを読む人も、どこから手を付けて良いのか分かりにくくなってきます。</p>
<p>同じ機能を実装するにしても、コードが縦にも横にも短く、儀式的なコードが減れば、ライブラリや技術へのキャッチアップコストも減りますし、読んで理解するのも簡単になります。また、型の恩恵も受けやすいとなると、開発がかなり加速するでしょう。</p>
</div>
</div>
<div class="section" id="id8">
<h2>まとめ<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>これで一通り、Reactを使う環境ができました。最低限の設定ですが、TypeScriptを使ったビルドや、開発サーバーの起動などもできるようになりました。</p>
<p>フロントエンドは開発環境を整えるのが大変、すぐに変わる、みたいなことがよく言われますが、ここ10年の間、やりたいこと自体は変わっていません。1ファイルでの開発は大変なので複数ファイルに分けて、デプロイ用にはバンドルして1ファイルにまとめる。ブラウザにロードしてデバッグする以前にコード解析で問題をなるべく見つけるようにする。ここ5年ぐらいは主要なのコンポーネントもだいたい固定されてきているように思います。State of JavaScript Surveyという調査をみると、シェアが高いライブラリはますますシェアを高めていっており、変化は少なくなってきています。一方で、React自体はより良い書き方ができるように進歩しています。</p>
<ul class="simple">
<li><p><a class="reference external" href="https://2019.stateofjs.com/">https://2019.stateofjs.com/</a></p></li>
</ul>
<p>CoffeeScriptや6to5に始まり、Babel、TypeScriptと、AltJSもいろいろ登場してきましたが、TypeScriptの人気は現在伸び率がナンバーワンです。それに応じて、各種環境構築ツールもTypeScriptをオプションの一つに加えており、ドキュメントでも必ず言及があります。デフォルトでTypeScriptが利用できるというツールも増えてきています。</p>
<p>本章の内容も、最初に書いたときよりも、どんどんコンパクトになってきています。もしかしたら、将来みなさんが環境構築をする時になったら本書の内容のほとんどの工程は不要になっているかもしれません。それはそれで望ましいので、早くそのような時代がきて、お詫びと訂正をしたいと思います。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="vue.html" class="btn btn-neutral float-right" title="Vue.jsの環境構築" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="browserobjects.html" class="btn btn-neutral float-left" title="ブラウザ関連の組み込み型" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 著作権 2019-2020, Future Corporation

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>