<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>成果物のデプロイ &mdash; 仕事ですぐに使えるTypeScript  ドキュメント</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/translations.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="使用ライブラリのバージョン管理" href="version.html" />
    <link rel="prev" title="CI（継続的インテグレーション）環境の構築" href="ci.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> 仕事ですぐに使えるTypeScript
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">TypeScriptの世界を知る</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preface.html">前書き</a></li>
<li class="toctree-l1"><a class="reference internal" href="ecosystem.html">Node.jsエコシステムを体験しよう</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TypeScriptの書き方</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="variable.html">変数</a></li>
<li class="toctree-l1"><a class="reference internal" href="primitive.html">プリミティブ型</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">複合型</a></li>
<li class="toctree-l1"><a class="reference internal" href="syntax.html">基本的な構文</a></li>
<li class="toctree-l1"><a class="reference internal" href="typing.html">基本的な型付け</a></li>
<li class="toctree-l1"><a class="reference internal" href="function.html">関数</a></li>
<li class="toctree-l1"><a class="reference internal" href="otherbuiltinobjects.html">その他の組み込み型・関数</a></li>
<li class="toctree-l1"><a class="reference internal" href="class.html">クラス</a></li>
<li class="toctree-l1"><a class="reference internal" href="async.html">非同期処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="exception.html">例外処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="module.html">モジュール</a></li>
<li class="toctree-l1"><a class="reference internal" href="console.html"><code class="docutils literal notranslate"><span class="pre">console.log</span></code>によるログ出力</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">中級のテクニック</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="generics.html">ジェネリクス</a></li>
<li class="toctree-l1"><a class="reference internal" href="functional.html">関数型指向のプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="class2.html">クラス上級編</a></li>
<li class="toctree-l1"><a class="reference internal" href="reactive.html">リアクティブ</a></li>
<li class="toctree-l1"><a class="reference internal" href="advance.html">高度なテクニック</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">環境ごとのTips（共通環境・ブラウザ以外）</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="prodenv.html">ソフトウェア開発の環境を考える</a></li>
<li class="toctree-l1"><a class="reference internal" href="baseenv.html">基本の環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="libenv.html">ライブラリ開発のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="clienv.html">CLIツール・ウェブサーバー作成のための環境設定</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">CI（継続的インテグレーション）環境の構築</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">成果物のデプロイ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#npm">npmパッケージとしてデプロイ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">サーバーにアプリケーションをデプロイ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#docker">Dockerイメージの作成</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">コンテナとは何か</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Dockerのベースイメージの選択</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cli">CLI/ウェブアプリケーションのイメージ作成</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#debiandocker">Debianベースのイメージ作成とDockerの基礎</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">Dockerイメージのビルドと実行</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distrolessdocker">distrolessベースのDockerイメージの作成</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id8">ウェブフロントエンドのDockerイメージの作成</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kubernetes">Kubernetesへのデプロイ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">Kubernetesの概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">Kubernetesをローカルで実行する</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id11">まとめ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="version.html">使用ライブラリのバージョン管理</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">環境ごとのTips（ブラウザ環境）</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="browserenv.html">ブラウザ環境</a></li>
<li class="toctree-l1"><a class="reference internal" href="browserobjects.html">ブラウザ関連の組み込み型</a></li>
<li class="toctree-l1"><a class="reference internal" href="react.html">Reactの環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="vue.html">Vue.jsの環境構築</a></li>
<li class="toctree-l1"><a class="reference internal" href="webparcel.html">Parcelを使ったウェブ開発</a></li>
<li class="toctree-l1"><a class="reference internal" href="electron.html">Electronアプリケーションの作成</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="recommended.html">おすすめのパッケージ・ツール</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html">貢献者</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">仕事ですぐに使えるTypeScript</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>成果物のデプロイ</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/deploy.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>成果物のデプロイ<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク"></a></h1>
<p>TypeScriptで作ったアプリケーションの開発環境の作り方を、バリエーションごとに紹介してきました。それぞれの環境でビルド方法についても紹介しました。本章ではデプロイについて紹介します。</p>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">課題</p>
<p>npmパッケージ to npm
npmパッケージ to nexus</p>
<p><a class="reference external" href="https://qiita.com/kannkyo/items/5195069c65350b60edd9">https://qiita.com/kannkyo/items/5195069c65350b60edd9</a></p>
</div>
<section id="npm">
<h2>npmパッケージとしてデプロイ<a class="headerlink" href="#npm" title="このヘッドラインへのパーマリンク"></a></h2>
<p>この方法でデプロイする対象は以下の通りです。</p>
<ul class="simple">
<li><p>Node.js用のライブラリ</p></li>
<li><p>Node.js用のCLIツール</p></li>
<li><p>Node.js用のウェブサービス</p></li>
</ul>
<p>ビルドしたらアーカイブファイルを作ってみましょう。これで、package.tgzファイルができます。npm installにこのファイルのパスを渡すとインストールできます。アップロードする前に、サンプルのプロジェクトを作ってみて、このパッケージをインストールしてみて、必要なファイルが抜けていないか、必要な依存パッケージが足りているかといったことを確認してみましょう。また、展開してみて、余計なファイルが含まれていないことも確認すると良いでしょう。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ npm pack
</pre></div>
</div>
<ul>
<li><p>ビルドには必要だが、配布する必要のないファイルが含まれている</p>
<p><code class="docutils literal notranslate"><span class="pre">.npmignore</span></code>ファイルにそのファイル名を列挙します。パッケージを作る時に無視されます。</p>
</li>
<li><p>ビルドには必要だが、利用環境でインストール不要なパッケージがある</p>
<p><code class="docutils literal notranslate"><span class="pre">package.json</span></code>の<code class="docutils literal notranslate"><span class="pre">dependencies</span></code>から、<code class="docutils literal notranslate"><span class="pre">devDependencies</span></code>に移動します。</p>
</li>
</ul>
<p>npmのサイトにアップロードしてみましょう。</p>
<p>パッケージリポジトリはnpm以外にもあります。例えば、Nexusを使えばローカルにパッケージリポジトリが建てられます。GitHubもパッケージリポジトリを提供しています。</p>
</section>
<section id="id3">
<h2>サーバーにアプリケーションをデプロイ<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク"></a></h2>
<p>Node.jsはシングルコアを効率よく使う処理系です。サーバーアプリケーションでマルチコアを効率よく使うには、プロセスマネージャを利用します。本書ではpm2を利用します。</p>
<ul class="simple">
<li><p><a class="reference external" href="https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/">https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/</a></p></li>
</ul>
<p>サンプルとしては次のコードを使います。</p>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-text">src/main.ts</span><a class="headerlink" href="#id12" title="このコードへのパーマリンク"></a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nx">express</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Request</span><span class="p">,</span> <span class="nx">Response</span> <span class="p">}</span> <span class="kr">from</span> <span class="s2">&quot;express&quot;</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">compression</span> <span class="kr">from</span> <span class="s2">&quot;compression&quot;</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">bodyParser</span> <span class="kr">from</span> <span class="s2">&quot;body-parser&quot;</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">gracefulShutdown</span> <span class="kr">from</span> <span class="s2">&quot;http-graceful-shutdown&quot;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">compression</span><span class="p">());</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">bodyParser</span><span class="p">.</span><span class="nx">json</span><span class="p">());</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">bodyParser</span><span class="p">.</span><span class="nx">urlencoded</span><span class="p">({</span> <span class="nx">extended</span>: <span class="kt">true</span> <span class="p">}));</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span>: <span class="kt">Request</span><span class="p">,</span> <span class="nx">res</span>: <span class="kt">Response</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span>
        <span class="nx">message</span><span class="o">:</span> <span class="sb">`hello </span><span class="si">${</span><span class="nx">req</span><span class="p">.</span><span class="nx">headers</span><span class="p">[</span><span class="s2">&quot;user-agent&quot;</span><span class="p">]</span><span class="si">}</span><span class="sb">`</span><span class="p">,</span>
    <span class="p">});</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">host</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">HOST</span> <span class="o">||</span> <span class="s2">&quot;0.0.0.0&quot;</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">port</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">PORT</span> <span class="o">||</span> <span class="mf">3000</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">port</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Server is running at http://%s:%d&quot;</span><span class="p">,</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;  Press CTRL-C to stop\n&quot;</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">gracefulShutdown</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">signals</span><span class="o">:</span> <span class="s2">&quot;SIGINT SIGTERM&quot;</span><span class="p">,</span>
    <span class="nx">timeout</span>: <span class="kt">30000</span><span class="p">,</span>
    <span class="nx">development</span>: <span class="kt">false</span><span class="p">,</span>
    <span class="nx">onShutdown</span>: <span class="kt">async</span> <span class="p">(</span><span class="nx">signal</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;... called signal: &quot;</span> <span class="o">+</span> <span class="nx">signal</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;... in cleanup&quot;</span><span class="p">);</span>
        <span class="c1">// shutdown DB or something</span>
    <span class="p">},</span>
    <span class="k">finally</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Server gracefulls shutted down.....&quot;</span><span class="p">);</span>
    <span class="p">},</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">tsconfig.json</span></code>は<code class="docutils literal notranslate"><span class="pre">npx</span> <span class="pre">tsc</span> <span class="pre">--init</span></code>で生成したものをひとまず使います。<code class="docutils literal notranslate"><span class="pre">package.json</span></code>は以下のものを利用します。nccを使ってビルドする前提となっています。</p>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-text">package.json</span><a class="headerlink" href="#id13" title="このコードへのパーマリンク"></a></div>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;webserver&quot;</span><span class="p">,</span>
  <span class="nt">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span><span class="p">,</span>
  <span class="nt">&quot;scripts&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;build&quot;</span><span class="p">:</span> <span class="s2">&quot;ncc build src/main.ts&quot;</span>
  <span class="p">},</span>
  <span class="nt">&quot;author&quot;</span><span class="p">:</span> <span class="s2">&quot;Yoshiki Shibukawa&quot;</span><span class="p">,</span>
  <span class="nt">&quot;license&quot;</span><span class="p">:</span> <span class="s2">&quot;ISC&quot;</span><span class="p">,</span>
  <span class="nt">&quot;dependencies&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;pm2&quot;</span><span class="p">:</span> <span class="s2">&quot;^4.4.0&quot;</span>
  <span class="p">},</span>
  <span class="nt">&quot;devDependencies&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;@types/body-parser&quot;</span><span class="p">:</span> <span class="s2">&quot;^1.19.0&quot;</span><span class="p">,</span>
    <span class="nt">&quot;@types/compression&quot;</span><span class="p">:</span> <span class="s2">&quot;^1.7.0&quot;</span><span class="p">,</span>
    <span class="nt">&quot;@types/express&quot;</span><span class="p">:</span> <span class="s2">&quot;^4.17.7&quot;</span><span class="p">,</span>
    <span class="nt">&quot;@zeit/ncc&quot;</span><span class="p">:</span> <span class="s2">&quot;^0.22.3&quot;</span><span class="p">,</span>
    <span class="nt">&quot;body-parser&quot;</span><span class="p">:</span> <span class="s2">&quot;^1.19.0&quot;</span><span class="p">,</span>
    <span class="nt">&quot;compression&quot;</span><span class="p">:</span> <span class="s2">&quot;^1.7.4&quot;</span><span class="p">,</span>
    <span class="nt">&quot;express&quot;</span><span class="p">:</span> <span class="s2">&quot;^4.17.1&quot;</span><span class="p">,</span>
    <span class="nt">&quot;http-graceful-shutdown&quot;</span><span class="p">:</span> <span class="s2">&quot;^2.3.2&quot;</span><span class="p">,</span>
    <span class="nt">&quot;typescript&quot;</span><span class="p">:</span> <span class="s2">&quot;^3.9.7&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>nccでビルドすると、dist/index.js``という一つの.jsファイルが生成されます。実行は<code class="docutils literal notranslate"><span class="pre">node</span> <span class="pre">dist/index.js</span></code>の変わりに次のコマンドを利用します。これで、CPUコア数分Node.jsのインスタンスを起動し、クラスタで動作します。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pm2 start dist/index.js -i max
</pre></div>
</div>
<p>pm2で起動すると、デーモン化されてアプリケーションが起動します。<code class="docutils literal notranslate"><span class="pre">pm2</span> <span class="pre">logs</span></code>コマンドでログをみたり、<code class="docutils literal notranslate"><span class="pre">pm2</span> <span class="pre">status</span></code>や<code class="docutils literal notranslate"><span class="pre">pm2</span> <span class="pre">list</span></code>で起動しているプロセスの状態を知ることができます。</p>
<p>デーモン化させないでフォアグラウンドで動作させる場合は<code class="docutils literal notranslate"><span class="pre">--no-daemon</span></code>をつけて起動します。</p>
</section>
<section id="docker">
<h2>Dockerイメージの作成<a class="headerlink" href="#docker" title="このヘッドラインへのパーマリンク"></a></h2>
<p>この方法でデプロイする対象は以下の通りです。</p>
<ul class="simple">
<li><p>Node.js用のCLIツール</p></li>
<li><p>Node.js用のウェブサービス</p></li>
<li><p>ウェブフロントエンド</p></li>
</ul>
<p>なお、本章のサンプルはベースイメージのバージョンは細かく指定していませんが、突然メジャーバージョンが上がってビルドできなくなることもあります。特に業務開発ではDocker Hubのイメージ情報のタグを見て、適宜バージョンを固定することをお勧めします。</p>
<section id="id4">
<h3>コンテナとは何か<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク"></a></h3>
<p>コンテナは1アプリケーションだけが格納されたミニOS環境です。Linux上でもmacOS上でもWindows上でもクラウド環境でも、アプリケーションからは同じOS環境のように見えます。ポータブルなアプリケーション配布・実行環境としてますます地位が高まっています。コンテナは動いている環境のことを指します。コンテナは実行時にイメージを読み込んで環境を構築します。これは実行に必要なファイルと起動時のコマンドなどがセットになったものです。開発者が作るのはイメージです。</p>
<p>コンテナ関係のシステムは、実行のランタイムやビルド方法など、それぞれにいくつか選択肢がありますが、開発時の環境として一番ポピュラーなのがDockerです。本書ではコンテナ=Dockerコンテナとして説明をします。</p>
<p>ローカルではコンテナはDocker for Desktopを使ってイメージの作成や動作のテストができます。運用環境として、どのクラウド事業者もKubernetesを使ってコンテナベースで本番運用環境の維持管理できるサービスを提供しています。1つのノードにリソースが許すかぎり多数のコンテナを配置することができ、実行時の効率も上がります。
それ以外にも、AWS ECSやAWS Fargate、GCP Cloud Runなど、単体のDockerイメージやDockerイメージ群を起動できるサービスもあります。コンテナはウェブアプリケーションのような起動し続けるサービスにも使えますし、一度実行して終了するバッチ処理にも活用できます。</p>
<p>Dockerコンテナ内のアプリケーションは外部の環境と切り離されて実行されますが、Dockerの実行時のオプションで外界と接点を設定できます。複雑な設定が必要なアプリケーションの場合は、設定ファイルをコンテナ内の特定のパスに置くこともできますが、推奨されるのは環境変数のみによって制御されるアプリケーションです。</p>
<ul class="simple">
<li><p>環境変数</p></li>
<li><p>ネットワークの設定</p>
<ul>
<li><p>特定のポートをlocalhostに公開</p></li>
<li><p>localhostとコンテナ内部のを同一ネットワークにするかどうか</p></li>
</ul>
</li>
<li><p>ファイルやフォルダのマウント</p></li>
<li><p>最後に実行するコマンドのオプション</p></li>
</ul>
<p>コンテナは上記のように、クラウドサービスに直接デプロイして実行できます。</p>
<p>複数のコンテナに必要な設定を与えてまとめて起動するツール（コンテナオーケストレーションツール）もあります。それがdocker-composeやKubernetesです。</p>
</section>
<section id="id5">
<h3>Dockerのベースイメージの選択<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク"></a></h3>
<p>Dockerイメージを作成するには<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>という設定ファイルを作成し、<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code>コマンドを使ってイメージを作成します。ベースイメージと呼ばれる土台となるイメージを選択して、それに対して必要なファイルを追加します。ビルド済みのアプリケーションを単に置く、という構築方法もありますが（公式イメージの多くはそれに近いことをしている）、アプリケーション開発の場合はソースコードをDocker内部に送り、それをDocker内部でビルドして、実行用イメージを作成します。できあがったイメージをコンパクトにするために、ビルド用イメージと、実行用イメージを分ける（マルチステージビルド）が今の主流です。</p>
<p>Node.jsの公式のイメージは以下のサイトにあります。</p>
<ul class="simple">
<li><p><a class="reference external" href="https://hub.docker.com/_/node/">https://hub.docker.com/_/node/</a></p></li>
</ul>
<p>バージョンと、OSの組み合わせだけイメージがあります。その中でおすすめの組み合わせが次の3つです。</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>用途</p></th>
<th class="head"><p>バリエーション</p></th>
<th class="head"><p>ビルド用イメージ</p></th>
<th class="head"><p>実行用イメージ</p></th>
<th class="head"><p>解説</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Node.js(CLI/ウェブアプリ)</p></td>
<td><p>鉄板</p></td>
<td><p>nodeのDebian系</p></td>
<td><p>nodeのDebian-slim系</p></td>
<td><p>ネイティブ拡張があっても利用可能</p></td>
</tr>
<tr class="row-odd"><td><p>Node.js(CLI/ウェブアプリ)</p></td>
<td><p>ネイティブ拡張なし</p></td>
<td><p>nodeのDebian-slim系</p></td>
<td><p>nodeのDebian-slim系</p></td>
<td><p>ビルド環境もコンパクトに</p></td>
</tr>
<tr class="row-even"><td><p>Node.js(CLI/ウェブアプリ)</p></td>
<td><p>セキュリティ重視</p></td>
<td><p>nodeのDebian-slim系</p></td>
<td><p>distrolessのnode.js</p></td>
<td><p>コンテナへのログインを許さないセキュアな実行イメージ</p></td>
</tr>
<tr class="row-odd"><td><p>ウェブフロントエンド配信</p></td>
<td></td>
<td><p>nodeのDebian-slim系</p></td>
<td><p>nginx:alpine</p></td>
<td></td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="id6">
<p class="admonition-title">課題</p>
<p>Denoはこちらのスレッドを見守る <a class="reference external" href="https://github.com/denoland/deno/issues/3356">https://github.com/denoland/deno/issues/3356</a></p>
</div>
<p>DebianはLinuxディストリビューションの名前です。buster (Debian 10)、stretch (Debian 9)、jessie (Debian 8)が執筆時点ではコンテナリポジトリにあります。それぞれ、無印がフル版で、gccや各種開発用ライブラリを含みます。いろいろ入っていて便利ですが、イメージサイズは大きめです。slimがつくバージョンがそれぞれにあります。これはNode.jsは入っているが、gccなどがないバージョンです。例えば、最新LTS（執筆時点で12）のDebianの開発環境込みのイメージであれば、<code class="docutils literal notranslate"><span class="pre">node:12-buster</span></code>を選びます。</p>
<p>もう一つ、GCPのコンテナレジストリで提供されているのがdistrolessです。こちらはシェルもなく、セキュリティパッチも積極的に当てていくという、セキュリティにフォーカスしたDebianベースのイメージです。
シェルがないということはリモートログインができませんので、踏み台にされる心配がないイメージです。これはGCPのコンテナレジストリに登録されており、<code class="docutils literal notranslate"><span class="pre">gcr.io/distroless/nodejs</span></code>という名前で利用可能です。</p>
<p>Alpineというサイズ重視のOSイメージはありますが、あとから追加インストールしなければならないパッケージが増えがちなのと、パッケージのバージョン固定がしにくい（古いパッケージが削除されてしまってインストールできなくなる）などの問題がありますし、他のイメージがだいたいDebianベースなので、Debianベースのもので揃えておいた方がトラブルは少ないでしょう。</p>
<p>Dockerイメージはサイズが重視されますが、ビルド時間や再ビルド時間も大切な要素です。開発ツールなしのイメージ（slimやalpineなど）を選び、必要な開発ツールだけをダウンロードするのはサイズの上では有利ですが、すでにできあがったイメージをただダウンロードするのよりも、依存関係を計算しながら各パッケージをダウンロードする方が時間がかかります。</p>
</section>
</section>
<section id="cli">
<h2>CLI/ウェブアプリケーションのイメージ作成<a class="headerlink" href="#cli" title="このヘッドラインへのパーマリンク"></a></h2>
<p>CLIとウェブアプリケーションの場合の手順はあまり変わらないので一緒に説明します。ベースイメージの選択では3種類の組み合わせがありました。</p>
<ul class="simple">
<li><p>C拡張あり（Debian系でビルド）</p></li>
<li><p>C拡張なし（Debian-slim系でビルド）</p></li>
<li><p>セキュリティ重視（destrolessに配信）</p></li>
</ul>
<p>前2つ目はベースイメージが<code class="docutils literal notranslate"><span class="pre">node:12-buster</span></code>から<code class="docutils literal notranslate"><span class="pre">node:12-buster-slim</span></code>に変わるだけですので、まとめて紹介します。</p>
<p>なお、Node.jsはシングルコアで動作する処理系ですので、マルチコアを生かしたい場合はインスタンスを複数起動し、ロードバランスをする仕組みを外部に起動する必要があります。</p>
<section id="debiandocker">
<h3>Debianベースのイメージ作成とDockerの基礎<a class="headerlink" href="#debiandocker" title="このヘッドラインへのパーマリンク"></a></h3>
<p>まず、イメージにするアプリケーションを作成します。コンテナの中のアプリケーションは終了時にシグナルが呼ばれますので、シグナルに応答して終了するように実装する必要があります。</p>
<p><code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>はコンテナのイメージを作成するためのレシピです。行志向のスクリプトになっています。WindowsやmacOSでは、Linuxが動作している仮想PCの中でDockerのサーバーが動作しており（Windowsの場合はWindowsも動作しますが、ここでは無視します）、ビルドを実行すると、実行されているフォルダの配下のファイル（コンテキスト）と<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>が、まとめてサーバーに送られます。サーバーの中で、<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>に書かれた命令に従ってベースとなるディスクイメージに手を加えていきます。実行されるのはローカルコンピュータではないので、記述できるコマンドも、そのベースイメージのLinuxで使えるものに限られます。</p>
<p>そのため、<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>に問題があれば、Windows上でビルドや実行をしても、macOS上でビルドや実行をしても、まったく同じエラーが発生するはずです。バージョン番号や内部で使われるパッケージのバージョンはその時の最新を使うこともできるため、いつでもまったく同じにはならないかもしれませんが、どこで誰がどのOSで実行しても、同じイメージが作られます。この冪等性がDockerが重宝されるポイントです。</p>
<p>次のファイルが、実際に動作する<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>です。順を追って見ていきます。</p>
<div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-text">Dockerfile</span><a class="headerlink" href="#id14" title="このコードへのパーマリンク"></a></div>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="c"># ここから下がビルド用イメージ</span>

<span class="k">FROM</span> <span class="s">node:12-buster</span> <span class="k">AS</span> <span class="s">builder</span>

<span class="k">WORKDIR</span><span class="s"> app</span>
<span class="k">COPY</span> package.json package-lock.json ./
<span class="k">RUN</span> npm ci
<span class="k">COPY</span> tsconfig.json ./
<span class="k">COPY</span> src ./src
<span class="k">RUN</span> npm run build

<span class="c"># ここから下が実行用イメージ</span>

<span class="k">FROM</span> <span class="s">node:12-buster-slim</span> <span class="k">AS</span> <span class="s">runner</span>
<span class="k">WORKDIR</span><span class="s"> /opt/app</span>
<span class="k">COPY</span> --from<span class="o">=</span>builder /app/dist ./
<span class="k">USER</span><span class="s"> node</span>
<span class="k">EXPOSE</span><span class="s"> 3000</span>
<span class="k">CMD</span> <span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">,</span> <span class="s2">&quot;/opt/app/index.js&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">FROM</span></code>はベースとなるイメージを選択する命令です。ここではビルド用のベースイメージと、実行用のベースイメージと2箇所<code class="docutils literal notranslate"><span class="pre">FROM</span></code>を使用しています。<code class="docutils literal notranslate"><span class="pre">FROM</span></code>から次の<code class="docutils literal notranslate"><span class="pre">FROM</span></code>、あるいはファイルの終行までがイメージになります。ここでは2つイメージが作られていますが、最後のイメージが、このDockerfileの成果物のイメージとなります。わざわざ2つに分けるのは、アクロバティックなことをしないで最終的なイメージサイズを小さくするためです。</p>
<p>それぞれのイメージの中ではいくつかの命令を使ってイメージを完成させていきます。</p>
<p><code class="docutils literal notranslate"><span class="pre">COPY</span></code>は実行場所（コンテキスト）や別のイメージ（<code class="docutils literal notranslate"><span class="pre">--from</span></code>が必要）からファイルを取得してきて、イメージ内部に配置する命令です。このサンプルでは使っていませんが、<code class="docutils literal notranslate"><span class="pre">ADD</span></code>命令もあり、こちらは<code class="docutils literal notranslate"><span class="pre">COPY</span></code>の高性能バージョンです。ネットワーク越しにファイルを取得できますし、アーカイブファイルを展開してフォルダに配置もできます。<code class="docutils literal notranslate"><span class="pre">RUN</span></code>は何かしらの命令を実行します。</p>
<p>重要なポイントが、このイメージ作成のステップ（行）ごとに内部的にはイメージが作成されている点です。このステップごとのファイルシステムの状態は「レイヤー」と呼ばれます。このレイヤーはキャッシュされて、コンテキストとファイルシステムの状態に差分がなければキャッシュを利用します。イメージの内部にはこのレイヤーがすべて保存されています。実行用イメージはこのレイヤーとサイズの問題は心の片隅に置いておく方が良いですが（優先度としては10番目ぐらいです）、ビルド用のイメージはサイズが大きくなっても弊害とかはないので、なるべくステップを分けてキャッシュされるようにすべきです。また、キャッシュ効率をあげるために、なるべく変更が少ない大物を先にインストールすることが大切です。</p>
<p>上記のサンプルではパッケージ情報ファイル（<code class="docutils literal notranslate"><span class="pre">package.json</span></code>と<code class="docutils literal notranslate"><span class="pre">package-lock.json</span></code>）取得してきてサードパーティのライブラリのダウンロード（<code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">install</span></code>）だけを先に実行しています。利用パッケージの変更はソースコードの変更よりもレアケースです。一方、ソースコードの変更は大量に行われます。そのためにソースコードのコピーを後に行っています。もし逆であれば、ソースコード変更のたびにパッケージのダウンロードが走り、キャッシュがほとんど有効になりません。このようにすれば、ソースコードを変更して再ビルドするときは<code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">src</span></code>の行より以前はスキップされてそこから先だけが実行されます。</p>
<p>実行用イメージの最後は<code class="docutils literal notranslate"><span class="pre">CMD</span></code>命令を使います。シェルスクリプトで実行したいプログラムを記述するのと同じように記述すれば問題ありません。最後の<code class="docutils literal notranslate"><span class="pre">CMD</span></code>は、常時起動しつづけるウェブサーバーであっても、一通り処理を実行して終了するバッチコマンドであっても、どちらでもかまいません。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><strong>Dockerとイメージサイズ削減</strong></p>
<p>今回紹介している、ビルド用イメージと実行用イメージなど、複数イメージを利用してイメージを作成する方法は「マルチステージビルド」と呼ばれます。</p>
<p>すべてのステップがレイヤーとして保存されると紹介しました。例えば、ファイルを追加、そして削除をそれぞれ1ステップずつ実行すると、消したはずのファイルもレイヤーには残ってしまい、イメージサイズは大きなままとなります。</p>
<p>マルチステージビルドがなかった時代は、なるべくレイヤーを作らないことでイメージサイズを減らそうとしていました。例えば、C++コンパイラをパッケージマネージャを使ってインストールし、ビルドを実行し、コンパイラを削除するというところまで、一つのRUNコマンドで行うこともありました。これであれば、結果のレイヤーは一つですし、ビルド済みのバイナリだけが格納されるのでサイズは増えません。次のコードは<a class="reference external" href="https://github.com/docker-library/redis">Redisの実際のリポジトリ</a>から取得してきたものです。Redis 3.0当時のもので、今はもっと複雑ですが、この場合は試行錯誤すると、毎回パッケージのダウンロードが始まります。もはやこのようなことは不要です。</p>
<div class="highlight-Dockerfile notranslate"><div class="highlight"><pre><span></span><span class="k">RUN</span> <span class="nv">buildDeps</span><span class="o">=</span><span class="s1">&#39;gcc libc6-dev make&#39;</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> <span class="nb">set</span> -x <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get update <span class="o">&amp;&amp;</span> apt-get install -y <span class="nv">$buildDeps</span> --no-install-recommends <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm -rf /var/lib/apt/lists/* <span class="se">\</span>
    <span class="o">&amp;&amp;</span> mkdir -p /usr/src/redis <span class="se">\</span>
    <span class="o">&amp;&amp;</span> curl -sSL <span class="s2">&quot;</span><span class="nv">$REDIS_DOWNLOAD_URL</span><span class="s2">&quot;</span> -o redis.tar.gz <span class="se">\</span>
    <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$REDIS_DOWNLOAD_SHA1</span><span class="s2"> *redis.tar.gz&quot;</span> <span class="p">|</span> sha1sum -c - <span class="se">\</span>
    <span class="o">&amp;&amp;</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components<span class="o">=</span><span class="m">1</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm redis.tar.gz <span class="se">\</span>
    <span class="o">&amp;&amp;</span> make -C /usr/src/redis <span class="se">\</span>
    <span class="o">&amp;&amp;</span> make -C /usr/src/redis install <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm -r /usr/src/redis <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get purge -y --auto-remove <span class="nv">$buildDeps</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><strong>ビルド時間を確実に短くするテクニック</strong></p>
<p>最初に、ローカルのファイルを一式Dockerのサーバーに送信すると説明しました。<code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code>ファイルがあれば、そのサーバーに送るファイルを減らし、ビルドが始まるまでの時間が短縮されます。また、余計なファイルが変更されることでキャッシュが破棄されることを減らします。</p>
<p>明らかに巨大になるのが次の2ファイルです。この2つは最低限列挙しましょう。<code class="docutils literal notranslate"><span class="pre">.git</span></code>を指定しないと、ブランチを切り替えただけで再ビルドになります。</p>
<div class="literal-block-wrapper docutils container" id="id15">
<div class="code-block-caption"><span class="caption-text">.dockerignore</span><a class="headerlink" href="#id15" title="このコードへのパーマリンク"></a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>node_modules
.git
</pre></div>
</div>
</div>
</div>
</section>
<section id="id7">
<h3>Dockerイメージのビルドと実行<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク"></a></h3>
<p>Dockerfileができたらイメージをビルドして実行してみましょう。名前をつけなくても、最後に作成したものなので実行直後は迷子にはならないのですが、何かしら名前をつけておく方が何かと良いです。ハッシュな識別子はかならず生成されるので、削除や実行にはこの識別子も使えます。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># ビルド。作成したイメージにwebserverと名前をつける</span>
$ docker build -t <span class="o">[</span>イメージ名<span class="o">]</span> .

<span class="c1"># イメージ一覧</span>
$ docker images

<span class="c1"># イメージ削除</span>
$ docker rmi <span class="o">[</span>イメージ名<span class="o">]</span>
</pre></div>
</div>
<p>実行は次の通りです。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 実行</span>
$ docker run -it --rm --name <span class="o">[</span>コンテナ名<span class="o">]</span> -p <span class="s2">&quot;3000:3000&quot;</span> <span class="o">[</span>イメージ名<span class="o">]</span>

<span class="c1"># 実行中コンテナの表示（-aをつけると停止中のものも表示）</span>
$ docker ps -a

<span class="c1"># コンテナ停止（-dで実行していなければ、Ctrl+Cで停止可能）</span>
$ docker stop <span class="o">[</span>コンテナ名<span class="o">]</span>

<span class="c1"># 停止済みコンテナの削除</span>
$ docker rm <span class="o">[</span>コンテナ名<span class="o">]</span>
</pre></div>
</div>
<p>説明によってはデーモン化のための<code class="docutils literal notranslate"><span class="pre">-d</span></code>オプションを紹介しているものもありますが、ログを見たりもあると思いますし、簡単に停止ができるようにこのオプションは付けずに実行する方が便利です。代わりに、実行しているターミナルに接続して情報を出力するために<code class="docutils literal notranslate"><span class="pre">-it</span></code>（ハイフンは一つ）を付けます。また、Dockerを停止すると、停止状態になり、その後削除は<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">rm</span></code>コマンドを実行しなければなりませんが、<code class="docutils literal notranslate"><span class="pre">--rm</span></code>をつけると、停止時に削除まで行ます。<code class="docutils literal notranslate"><span class="pre">-p</span></code>はあけたいポート番号です。左がホスト、右がDocker内部のプロセスのポートです。今回は同じなので、<cite>-p &quot;3000:3000&quot;</cite>を指定します。もし、コンテナ内部が80であれば、<cite>-p &quot;3000:80&quot;</cite>になります。</p>
</section>
<section id="distrolessdocker">
<h3>distrolessベースのDockerイメージの作成<a class="headerlink" href="#distrolessdocker" title="このヘッドラインへのパーマリンク"></a></h3>
<p>distrolessはシェルが入っておらず、外部からログインされることもなく安全というGoogle製のDockerイメージです。標準Linuxに入っているようなツールも含めて、最小限にカットされています。Node.js、Java、Python、.netなど言語のランタイムだけが入ったバージョン、llvmベースのコンパイラで作成したコードを動かすだけのバージョン、何もないバージョンなど、いくつかのバリエーションが用意されています。今回はNode.jsを使います。</p>
<p>現在、8種類タグが定義されています。latestはLTSが終わるまでは10のままです。<code class="docutils literal notranslate"><span class="pre">debug</span></code>がついているものはデバッグ用のシェルが内蔵されています。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gcr.io/distroless/nodejs:latest</span></code>: 10と同じ</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gcr.io/distroless/nodejs:10</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gcr.io/distroless/nodejs:12</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gcr.io/distroless/nodejs:14</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gcr.io/distroless/nodejs:10</span></code>: 10-debugと同じ</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gcr.io/distroless/nodejs:10-debug</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gcr.io/distroless/nodejs:12-debug</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gcr.io/distroless/nodejs:14-debug</span></code></p></li>
</ul>
<p>一般的な<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>は、<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>がシェル、<code class="docutils literal notranslate"><span class="pre">CMD</span></code>がそのシェルから呼び出されるプログラムです。distrolessはシェルがなく、<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>にNode.jsが設定されているので、<code class="docutils literal notranslate"><span class="pre">CMD</span></code>にはJavaScriptのスクリプトを設定します。拡張を使わないコードなら簡単に動作します。先ほどの<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>と、ビルド部分はまったく同じです。</p>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-text">Dockerfile</span><a class="headerlink" href="#id16" title="このコードへのパーマリンク"></a></div>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="c"># ここから下がビルド用イメージ</span>

<span class="k">FROM</span> <span class="s">node:12-buster</span> <span class="k">AS</span> <span class="s">builder</span>

<span class="k">WORKDIR</span><span class="s"> app</span>
<span class="k">COPY</span> package.json package-lock.json ./
<span class="k">RUN</span> npm ci
<span class="k">COPY</span> tsconfig.json ./
<span class="k">COPY</span> src ./src
<span class="k">RUN</span> npm run build

<span class="c"># ここから下が実行用イメージ</span>

<span class="k">FROM</span> <span class="s">gcr.io/distroless/nodejs</span> <span class="k">AS</span> <span class="s">runner</span>
<span class="k">WORKDIR</span><span class="s"> /opt/app</span>
<span class="k">COPY</span> --from<span class="o">=</span>builder /app/dist ./
<span class="k">EXPOSE</span><span class="s"> 3000</span>
<span class="k">CMD</span> <span class="p">[</span><span class="s2">&quot;/opt/app/index.js&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="id8">
<h2>ウェブフロントエンドのDockerイメージの作成<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク"></a></h2>
<p>本節ではウェブフロントエンドが一式格納されたDockerイメージを作成します。もし、Next.jsでサーバーサイドレンダリングを行う場合、それは単なるNode.jsのサーバーですので、前節の内容に従ってNode.jsのコンテナを作成してください。本節で扱うのは、サーバーを伴わないHTML/JavaScriptなどのフロントエンドのファイルを配信する方法です。</p>
<p>シングルページアプリケーションをビルドすると静的なHTMLやJS、CSSのファイル群ができます。これらのファイルを利用する方法はいくつかあります。</p>
<ul class="simple">
<li><p>CDNやオブジェクトストレージにアップする</p></li>
<li><p>Dockerコンテナとしてデプロイする</p></li>
</ul>
<p>このうち、CDNやオブジェクトストレージへのアップロードはそれぞれのサービスごとの作法に従って行ます。ここではDockerコンテナとしてデプロイする方法を紹介します。Dockerコンテナにするメリットはいくつかあります。主にテスト環境の構築がしやすい点です。</p>
<p>デプロイ用のバックエンドサーバーをDocker化する流れは今後も加速していくでしょう。しかし、フロントエンドが特定のマネージドサービスにアップロードする形態の場合、デプロイ手段がバックエンドと異なるため、別のデプロイ方式を取る必要が出てきます。ちょっとしたステージング環境や、開発環境を構築する際に、フロントエンドもDockerイメージになっていて本番環境のCDNをエミュレートできると、ローカルでもサーバーでも、簡単に一式のサービスが起動できます。PostgreSQLのイメージや、Redisのイメージ、クラウドサービスのエミューレータなどと一緒に、docker-composeで一度に起動するとテストが簡単に行えます。</p>
<p>サンプルとして、次のコマンドで作ったReactのアプリケーションを使います。もし、E2EテストのCypressのような、ダウンロードが極めて重い超巨大パッケージがある場合は、<code class="docutils literal notranslate"><span class="pre">optionalDependencies</span></code>に移動しておくことをお勧めします。この<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>ではoptionalな依存はインストールしないようにしています。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ npx create-react-app --template typescript webfront
</pre></div>
</div>
<p>Dockerコンテナにする場合、ウェブサーバーのNginxのコンテナイメージを基に、ビルド済みのJavaScript/HTML/その他のリソースを格納したコンテナイメージを作成します。次の内容が、フロントエンドアプリケーションの静的ファイルを配信するサーバーです。実行用イメージでは<code class="docutils literal notranslate"><span class="pre">nginx：alpine</span></code>イメージをベースに使っています。このイメージは最後にNginxを立ち上げる設定がされているため、実行用コンテナに必要なのは生成されたフィイルと、<code class="docutils literal notranslate"><span class="pre">nginx.conf</span></code>をコピーするだけです。</p>
<div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-text">Dockerfile</span><a class="headerlink" href="#id17" title="このコードへのパーマリンク"></a></div>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="c"># ここから下がビルド用イメージ</span>

<span class="k">FROM</span> <span class="s">node:12-buster</span> <span class="k">AS</span> <span class="s">builder</span>

<span class="k">WORKDIR</span><span class="s"> app</span>
<span class="k">COPY</span> package.json package-lock.json ./
<span class="k">RUN</span> npm ci --no-optional
<span class="k">COPY</span> tsconfig.json ./
<span class="k">COPY</span> public ./public
<span class="k">COPY</span> src ./src
<span class="k">RUN</span> npm run build

<span class="c"># ここから下が実行用イメージ</span>

<span class="k">FROM</span> <span class="s">nginx:alpine</span> <span class="k">AS</span> <span class="s">runner</span>
<span class="k">COPY</span> nginx.conf /etc/nginx/nginx.conf
<span class="k">COPY</span> --from<span class="o">=</span>builder /app/build public
<span class="k">EXPOSE</span><span class="s"> 80</span>
</pre></div>
</div>
</div>
<p>配信用のnginxの設定です。シングルページアプリケーションにとって大切なパートが<code class="docutils literal notranslate"><span class="pre">try_files</span></code>です。シングルページアプリケーションでは1つのHTML/JSがあらゆるページを作り上げます。そしてその時にURLを書き換えます。しかし、そこでブラウザリロードをすると、JavaScriptによって作られた仮想的なURLを読みにこうとします。この<code class="docutils literal notranslate"><span class="pre">try_files</span></code>を有効にすると、一度アクセスしに行って見つからなかった場合にオプションで設定したファイルを返せます。ここでは<code class="docutils literal notranslate"><span class="pre">index.html</span></code>を返すので、そこでReact Routerなどのフロントで動作しているウェブサービスが仕分けを行い、もしどこにもマッチしなければフロント側のRouterがエラーをハンドリングできます。</p>
<div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text">nginx.conf</span><a class="headerlink" href="#id18" title="このコードへのパーマリンク"></a></div>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">worker_processes</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">events</span> <span class="p">{</span>
    <span class="kn">worker_connections</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="kn">multi_accept</span> <span class="no">on</span><span class="p">;</span>
    <span class="kn">use</span> <span class="s">epoll</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">http</span> <span class="p">{</span>
    <span class="kn">include</span> <span class="s">/etc/nginx/mime.types</span><span class="p">;</span>
    <span class="kn">server</span> <span class="p">{</span>
        <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
        <span class="kn">server_name</span> <span class="mi">127</span><span class="s">.0.0.1</span><span class="p">;</span>

        <span class="kn">access_log</span> <span class="s">/dev/stdout</span><span class="p">;</span>
        <span class="kn">error_log</span> <span class="s">stderr</span><span class="p">;</span>

        <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>
            <span class="kn">root</span> <span class="s">/public</span><span class="p">;</span>
            <span class="kn">index</span> <span class="s">index.html</span><span class="p">;</span>
            <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="s">/index.html</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>
            <span class="kn">gzip</span> <span class="no">on</span><span class="p">;</span>
            <span class="kn">gzip_types</span> <span class="s">text/css</span> <span class="s">application/javascript</span> <span class="s">application/json</span> <span class="s">image/svg+xml</span><span class="p">;</span>
            <span class="kn">gzip_comp_level</span> <span class="mi">9</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>それではビルドして実行してみましょう。正しく動作していることが確認できます。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker run -it --rm --name <span class="o">[</span>コンテナ名<span class="o">]</span> -p <span class="s2">&quot;3000:80&quot;</span> <span class="o">[</span>イメージ名<span class="o">]</span>
</pre></div>
</div>
<figure class="align-default" id="id19">
<img alt="_images/react_nginx_sample.png" src="_images/react_nginx_sample.png" />
<figcaption>
<p><span class="caption-text">ビルドした結果をNginxで配信</span><a class="headerlink" href="#id19" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><a class="reference external" href="https://qiita.com/shibukawa/items/6a3b4d4b0cbd13041e53">https://qiita.com/shibukawa/items/6a3b4d4b0cbd13041e53</a></p>
</div>
</section>
<section id="kubernetes">
<h2>Kubernetesへのデプロイ<a class="headerlink" href="#kubernetes" title="このヘッドラインへのパーマリンク"></a></h2>
<p>このセクションでは、作成したアプリケーションのDockerイメージをKubernetesの上で動かすための基本について説明します。</p>
<section id="id9">
<h3>Kubernetesの概要<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク"></a></h3>
<p>KubernetesはGoogleが自社の基盤をOSSとして1から再実装したソフトウェアです。アプリケーションのデプロイ単位としてDockerコンテナを用いており、開発者はコンテナイメージを作成して配信することによって、Kubernetesの上でアプリケーションを動かすことができます。</p>
<p>コンテナアプリケーションを本番で稼働するにあたっては、サービスを停止せずにアップデートする方法や、複数のコンテナを水平にスケールしながら負荷分散する機能など、さまざまな運用面での課題を解決する必要がありますが、Kubernetesではそれらの機能を一貫して提供してくれるメリットがあります。</p>
</section>
<section id="id10">
<h3>Kubernetesをローカルで実行する<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク"></a></h3>
<p>Kubernetesをローカルで実行するには以下のようなツールを使う方法があります。</p>
<ul class="simple">
<li><p>minikube</p></li>
<li><p>kind</p></li>
<li><p>microk8s</p></li>
</ul>
<p>このうち、minikubeとkindでは手元のDocker上でKubernetesを動かすことができるため、Linux上でDockerを動かさずとも手元のmacOSやWindows上でDocker Desktopを使って簡単にKubernetesを立ち上げることができます。microk8sに関してはLinux上でのサポートに限られます(特にUbuntuが推奨されます)が、依存するパッケージが少ないためインストールがシンプルであるメリットがあります。ここではminikubeを使ってKubernetesを動かしてみましょう。</p>
<p>minikubeのインストール方法は以下の公式ドキュメントにあります。</p>
<ul class="simple">
<li><p><a class="reference external" href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># minikubeを起動</span>
$ minikube start
😄  Ubuntu <span class="m">20</span>.04 上の minikube v1.12.1
✨  Automatically selected the docker driver

❗  <span class="s1">&#39;docker&#39;</span> driver reported a issue that could affect the performance.
💡  Suggestion: <span class="nb">enable</span> overlayfs kernel module on your Linux

👍  Starting control plane node minikube <span class="k">in</span> cluster minikube
🔥  Creating docker container <span class="o">(</span><span class="nv">CPUs</span><span class="o">=</span><span class="m">2</span>, <span class="nv">Memory</span><span class="o">=</span>2200MB<span class="o">)</span> ...
🐳  Docker <span class="m">19</span>.03.2 で Kubernetes v1.18.3 を準備しています...
🔎  Verifying Kubernetes components...
🌟  Enabled addons: default-storageclass, storage-provisioner
🏄  Done! kubectl is now configured to use <span class="s2">&quot;minikube&quot;</span>
</pre></div>
</div>
<p>minikubeのセットアップが終わったら、kubectlをインストールします。kubectlはKubernetesのCLIツールで、Kubernetesそのものとは別途インストールする必要があります。各環境でのセットアップは以下のサイトを参考に行ってみてください。</p>
<ul class="simple">
<li><p><a class="reference external" href="https://kubernetes.io/ja/docs/tasks/tools/install-kubectl/">https://kubernetes.io/ja/docs/tasks/tools/install-kubectl/</a></p></li>
</ul>
<p>これでKubernetesを触るための準備が整いました。次に、アプリケーションの準備を行います。</p>
<p>あらかじめ、手元のDockerで任意のタグを付けてアプリケーションをビルドしておきます。例では <code class="docutils literal notranslate"><span class="pre">typescript-kubernetes:1.0.0</span></code>とします。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker build -t typescript-kubernetes:1.0.0 .
$ docker images
<span class="c1"># イメージ一覧が返ってくることを確認</span>
</pre></div>
</div>
<p>そうしたら、以下のYAMLファイルを作成します。</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">apps/v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Deployment</span>
<span class="nt">metadata</span><span class="p">:</span>
<span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes-deployment</span>
<span class="nt">spec</span><span class="p">:</span>
<span class="nt">selector</span><span class="p">:</span>
    <span class="nt">matchLabels</span><span class="p">:</span>
    <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes</span>
<span class="nt">replicas</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">3</span>
<span class="nt">template</span><span class="p">:</span>
    <span class="nt">metadata</span><span class="p">:</span>
    <span class="nt">labels</span><span class="p">:</span>
        <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes</span>
    <span class="nt">spec</span><span class="p">:</span>
    <span class="nt">containers</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes</span>
        <span class="l l-Scalar l-Scalar-Plain">image</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes:1.0.0</span>
        <span class="l l-Scalar l-Scalar-Plain">imagePullPolicy</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
        <span class="l l-Scalar l-Scalar-Plain">ports</span><span class="p p-Indicator">:</span>
        <span class="p p-Indicator">-</span> <span class="nt">containerPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
<span class="nn">---</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Service</span>
<span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">metadata</span><span class="p">:</span>
<span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes-service</span>
<span class="nt">labels</span><span class="p">:</span>
    <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes</span>
<span class="nt">spec</span><span class="p">:</span>
<span class="nt">ports</span><span class="p">:</span>
<span class="p p-Indicator">-</span> <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
    <span class="l l-Scalar l-Scalar-Plain">targetPort</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
<span class="nt">selector</span><span class="p">:</span>
    <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes</span>
<span class="nt">type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ClusterIP</span>
</pre></div>
</div>
<p>作成したYAMLをKubernetesに適用します。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f app.yaml
deployment.apps/typescript-kubernetes-deployment created
service/typescript-kubernetes-service created
$ kubectl get pod
NAME                                               READY   STATUS    RESTARTS   AGE
typescript-kubernetes-deployment-8bfd76d4c-2tsl6   <span class="m">1</span>/1     Running   <span class="m">0</span>          3m16s
typescript-kubernetes-deployment-8bfd76d4c-h6sdz   <span class="m">1</span>/1     Running   <span class="m">0</span>          3m13s
typescript-kubernetes-deployment-8bfd76d4c-sg2jz   <span class="m">1</span>/1     Running   <span class="m">0</span>          3m12s
$ kubectl get service
NAME                            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>   AGE
kubernetes                      ClusterIP   <span class="m">10</span>.96.0.1       &lt;none&gt;        <span class="m">443</span>/TCP   35m
typescript-kubernetes-service   ClusterIP   <span class="m">10</span>.107.196.16   &lt;none&gt;        <span class="m">80</span>/TCP    7m10s
</pre></div>
</div>
<p>作成したDeployment(複数のコンテナアプリケーションをまとめて管理できるリソース)とService(複数のコンテナアプリケーションをロードバランスしてくれるネットワークリソース)が稼働していることを確認したら、今度は動作を確認します。手元のシェルで <code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">port-forward</span></code>を実行し、Kubernetes上のアプリケーションを手元のブラウザで接続できるようにします。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl port-forward service/typescript-kubernetes-service <span class="m">8080</span>:80
Forwarding from <span class="m">127</span>.0.0.1:8080 -&gt; <span class="m">80</span>
Forwarding from <span class="o">[</span>::1<span class="o">]</span>:8080 -&gt; <span class="m">80</span>
</pre></div>
</div>
<p>ブラウザで <code class="docutils literal notranslate"><span class="pre">localhost:8080</span></code>にアクセスすると、作成されたアプリケーションがnginxの上で動いていることが確認できます。なお、本番などでマネージドサービスを利用する場合、ClusterIP + port-forwardを利用しなくとも、以下のようにLoadBalacnerサービスを使用することで、パブリッククラウドのロードバランサーと簡単に連携させることができます。</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Service</span>
<span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">metadata</span><span class="p">:</span>
<span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes-service</span>
<span class="nt">labels</span><span class="p">:</span>
   <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes</span>
<span class="nt">spec</span><span class="p">:</span>
<span class="nt">ports</span><span class="p">:</span>
<span class="p p-Indicator">-</span> <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
   <span class="l l-Scalar l-Scalar-Plain">targetPort</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
<span class="nt">selector</span><span class="p">:</span>
   <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">typescript-kubernetes</span>
<span class="nt">type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">LoadBalancer</span>
</pre></div>
</div>
<p>最後に、作成したminikubeの環境を削除します。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minikube delete
🔥  docker の「minikube」を削除しています...
🔥  Deleting container <span class="s2">&quot;minikube&quot;</span> ...
🔥  /home/kela/.minikube/machines/minikube を削除しています...
💀  Removed all traces of the <span class="s2">&quot;minikube&quot;</span> cluster.
</pre></div>
</div>
</section>
</section>
<section id="id11">
<h2>まとめ<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク"></a></h2>
<p>TypeScriptで作成したコードが価値を産むのは、何かしらのデプロイ作業を通じてになります。本章ではそのデプロイの方法について、さまざまな方法をを説明しています。</p>
<p>Dockerは強力な武器です。ぜひ使いこなせるようになってください。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ci.html" class="btn btn-neutral float-left" title="CI（継続的インテグレーション）環境の構築" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="version.html" class="btn btn-neutral float-right" title="使用ライブラリのバージョン管理" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020, Future Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>